{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"This is the first paragraph of the document.","title":"Home"},{"location":"command_line/","text":"Commnand line PyMS comes with some commands to make your developments easier: pyms -h Lists the options and help instructions to use this command: usage: main.py [-h] [-v VERBOSE] {encrypt,create-key,startproject,merge-swagger} ... Python Microservices optional arguments: -h, --help show this help message and exit -v VERBOSE, --verbose VERBOSE Verbose Commands: Available commands {encrypt,create-key,startproject,merge-swagger} encrypt Encrypt a string create-key Generate a Key to encrypt strings in config startproject Generate a project from https://github.com/python- microservices/microservices-template merge-swagger Merge swagger into a single file Start a project Command: pyms startproject This command creates a project template like the one defined in Microservices Scaffold . This command uses cookiecutter to download and install this template Warning First, you must run pip install cookiecutter==1.7.0 Create a key encrypt/decrypt file Command: pyms create-key Create a key file to encrypt strings in your configuration file. This key is created with AES . You can run the next command in the terminal. See Encrypt/Decrypt Configuration for more information Encrypt a string Command: pyms encrypt [string] Encrypt a string to use in your configfile pyms encrypt 'mysql+mysqlconnector://important_user:****@localhost/my_schema' >> Encrypted OK: b'gAAAAABeSwBJv43hnGAWZOY50QjBX6uGLxUb3Q6fcUhMxKspIVIco8qwwZvxRg930uRlsd47isroXzkdRRnb4-x2dsQMp0dln8Pm2ySHH7TryLbQYEFbSh8RQK7zor-hX6gB-JY3uQD3IMtiVKx9AF95D6U4ydT-OA==' See Encrypt/Decrypt Configuration for more information Merge swagger into a single file Command: pyms merge-swagger [-h] [-f FILE] optional arguments: -h, --help show this help message and exit -f FILE, --file FILE Swagger file path This command uses prance to validate the API specification and generate a single YAML file. It has an optional argument to indicate the main file path of the API specification. pyms merge-swagger --file 'app/swagger/swagger.yaml' >> Swagger file generated [swagger-complete.yaml] >> OK Create configuration from command line PyMS has a command line option to create a config file. You can run the next command in the terminal: pyms create-config","title":"Command line"},{"location":"command_line/#commnand-line","text":"PyMS comes with some commands to make your developments easier: pyms -h Lists the options and help instructions to use this command: usage: main.py [-h] [-v VERBOSE] {encrypt,create-key,startproject,merge-swagger} ... Python Microservices optional arguments: -h, --help show this help message and exit -v VERBOSE, --verbose VERBOSE Verbose Commands: Available commands {encrypt,create-key,startproject,merge-swagger} encrypt Encrypt a string create-key Generate a Key to encrypt strings in config startproject Generate a project from https://github.com/python- microservices/microservices-template merge-swagger Merge swagger into a single file","title":"Commnand line"},{"location":"command_line/#start-a-project","text":"Command: pyms startproject This command creates a project template like the one defined in Microservices Scaffold . This command uses cookiecutter to download and install this template Warning First, you must run pip install cookiecutter==1.7.0","title":"Start a project"},{"location":"command_line/#create-a-key-encryptdecrypt-file","text":"Command: pyms create-key Create a key file to encrypt strings in your configuration file. This key is created with AES . You can run the next command in the terminal. See Encrypt/Decrypt Configuration for more information","title":"Create a key encrypt/decrypt file"},{"location":"command_line/#encrypt-a-string","text":"Command: pyms encrypt [string] Encrypt a string to use in your configfile pyms encrypt 'mysql+mysqlconnector://important_user:****@localhost/my_schema' >> Encrypted OK: b'gAAAAABeSwBJv43hnGAWZOY50QjBX6uGLxUb3Q6fcUhMxKspIVIco8qwwZvxRg930uRlsd47isroXzkdRRnb4-x2dsQMp0dln8Pm2ySHH7TryLbQYEFbSh8RQK7zor-hX6gB-JY3uQD3IMtiVKx9AF95D6U4ydT-OA==' See Encrypt/Decrypt Configuration for more information","title":"Encrypt a string"},{"location":"command_line/#merge-swagger-into-a-single-file","text":"Command: pyms merge-swagger [-h] [-f FILE] optional arguments: -h, --help show this help message and exit -f FILE, --file FILE Swagger file path This command uses prance to validate the API specification and generate a single YAML file. It has an optional argument to indicate the main file path of the API specification. pyms merge-swagger --file 'app/swagger/swagger.yaml' >> Swagger file generated [swagger-complete.yaml] >> OK","title":"Merge swagger into a single file"},{"location":"command_line/#create-configuration-from-command-line","text":"PyMS has a command line option to create a config file. You can run the next command in the terminal: pyms create-config","title":"Create configuration from command line"},{"location":"configuration/","text":"Configuration Environments variables of PyMS: PYMS_CONFIGMAP_FILE : The path to the configuration file. By default, PyMS searches for the configuration file in your current folder with the name \"config.yml\" PYMS_KEY_FILE : The path to the key file to decrypt your configuration. By default, PyMS searches for the configuration file in your current folder with the name \"key.key\" Create configuration Each microservice needs a config file in yaml or json format for it to work with. This configuration contains the Flask settings of your project and the Services . With this way of creating configuration files, we solve two problems of the 12 Factor apps : Store config out of the code Dev/prod parity: the configuration could be injected and doesn't depend on our code, for example, Kubernetes configmaps A simple configuration file could be a config.yaml: pyms: services: requests: true swagger: path: \"\" file: \"swagger.yaml\" config: debug: true testing: false app_name: \"Python Microservice\" APPLICATION_ROOT: \"\" or in a config.json: { \"pyms\": { \"services\":{ \"requests\": true, \"swagger\": { \"path\": \"\", \"file\": \"swagger.yaml\" } }, \"config\": { \"DEBUG\": true, \"TESTING\": true, \"APP_NAME\": \"Python Microservice\", \"APPLICATION_ROOT\": \"/\", \"test_var\": \"general\", \"subservice1\": { \"test\": \"input\" }, \"subservice2\": { \"test\": \"output\" } } } } Create configuration from command line PyMS has a command line option to create a config file. You can run the next command in the terminal: pyms create-config Configuration file structure This file can contain the following keywords: pyms - services block pyms : all subsets inside this keyword are the settings of this library. Each keyword will be a service of our Microservice class . For example, if we declare our microservice class as: from pyms.flask.app import Microservice ms = Microservice(path=__file__) and have a config.yaml file such as: pyms: services: requests: true our ms object will have an attribute requests that is a instance of our service requests . pyms - config block This section contains all keywords used for general Flask Configuration Handling , along with our constants for the different enviroments (local configuration, staging configuration...). Keep in mind that a Flask app configuration needs the keywords to be declared as uppercase. If you defined a variable like app_name , you will be able to retrieve it with current_app.config[\"APP_NAME\"] Import Configuration With pyms, all configuration is stored as flask configuration and it can be acceded from: from flask import current_app; def my_endpoint(): print(current_app.config[\"DEBUG\"]) But, what happens if you need to access the configuration BEFORE Flask class is instanced? Imagine this case: from flask import Blueprint, current_app from flask_restplus import Api my_api_blueprint = Blueprint('api', __name__) API = Api( my_api_blueprint, title='My Microservice', version=current_app.config[\"APP_VERSION\"], description='Microservice to manage hierarchies', add_specs=True, ) This raises a 'working outside of application context error. Who can solve this problem? from flask import Blueprint, current_app from flask_restplus import Api from pyms.flask.app import config my_api_blueprint = Blueprint('api', __name__) API = Api( my_api_blueprint, title='My Microservice', version=config().APP_VERSION, description='Microservice to manage hierarchies', add_specs=True, ) Looking for Configuration file with Kubernetes Configmaps By default, the Microservice class searches for a config.yml in the same path. You can set a different route or set a json file. To change this path, you must define an environment variable called PYMS_CONFIGMAP_FILE . This way of looking for the configuration is useful when you work with Docker and Kubernetes. For example, you could integrate a configmap of Kubernetes, with this microservice and a deployment with: apiVersion: extensions/v1beta1 kind: Deployment metadata: name: my-microservice spec: replicas: 1 template: spec: containers: - name: my-microservice image: ... env: - name: PYMS_CONFIGMAP_FILE value: \"/usr/share/microservice/config.yaml\" volumeMounts: - mountPath: /usr/share/microservice name: ms-config-volume volumes: - name: ms-config-volume configMap: name: my-microservice-configmap See Routing and Examples to continue with this tutorial Reload configuration without stopping your services In a production environment you may need to change the microservice's configuration without restarting it. PyMS has a feature to reload the configuration: curl -X POST http://localhost:5000/reload-config This endpoint calls the method Microservice.reload_conf() , which restarts the services, the encryption configuration and initializes create_app . def reload_conf(self): self.delete_services() self.config.reload() self.services = [] self.init_services() self.crypt.config.reload() self.create_app() This means that your libraries will be restarted, which is why it's important to initialize your BD, your configuration inside init_libs method. See more info how to use Microservice class in this link","title":"Configuration"},{"location":"configuration/#configuration","text":"","title":"Configuration"},{"location":"configuration/#environments-variables-of-pyms","text":"PYMS_CONFIGMAP_FILE : The path to the configuration file. By default, PyMS searches for the configuration file in your current folder with the name \"config.yml\" PYMS_KEY_FILE : The path to the key file to decrypt your configuration. By default, PyMS searches for the configuration file in your current folder with the name \"key.key\"","title":"Environments variables of PyMS:"},{"location":"configuration/#create-configuration","text":"Each microservice needs a config file in yaml or json format for it to work with. This configuration contains the Flask settings of your project and the Services . With this way of creating configuration files, we solve two problems of the 12 Factor apps : Store config out of the code Dev/prod parity: the configuration could be injected and doesn't depend on our code, for example, Kubernetes configmaps A simple configuration file could be a config.yaml: pyms: services: requests: true swagger: path: \"\" file: \"swagger.yaml\" config: debug: true testing: false app_name: \"Python Microservice\" APPLICATION_ROOT: \"\" or in a config.json: { \"pyms\": { \"services\":{ \"requests\": true, \"swagger\": { \"path\": \"\", \"file\": \"swagger.yaml\" } }, \"config\": { \"DEBUG\": true, \"TESTING\": true, \"APP_NAME\": \"Python Microservice\", \"APPLICATION_ROOT\": \"/\", \"test_var\": \"general\", \"subservice1\": { \"test\": \"input\" }, \"subservice2\": { \"test\": \"output\" } } } }","title":"Create configuration"},{"location":"configuration/#create-configuration-from-command-line","text":"PyMS has a command line option to create a config file. You can run the next command in the terminal: pyms create-config","title":"Create configuration from command line"},{"location":"configuration/#configuration-file-structure","text":"This file can contain the following keywords:","title":"Configuration file structure"},{"location":"configuration/#pyms-services-block","text":"pyms : all subsets inside this keyword are the settings of this library. Each keyword will be a service of our Microservice class . For example, if we declare our microservice class as: from pyms.flask.app import Microservice ms = Microservice(path=__file__) and have a config.yaml file such as: pyms: services: requests: true our ms object will have an attribute requests that is a instance of our service requests .","title":"pyms - services block"},{"location":"configuration/#pyms-config-block","text":"This section contains all keywords used for general Flask Configuration Handling , along with our constants for the different enviroments (local configuration, staging configuration...). Keep in mind that a Flask app configuration needs the keywords to be declared as uppercase. If you defined a variable like app_name , you will be able to retrieve it with current_app.config[\"APP_NAME\"]","title":"pyms - config block"},{"location":"configuration/#import-configuration","text":"With pyms, all configuration is stored as flask configuration and it can be acceded from: from flask import current_app; def my_endpoint(): print(current_app.config[\"DEBUG\"]) But, what happens if you need to access the configuration BEFORE Flask class is instanced? Imagine this case: from flask import Blueprint, current_app from flask_restplus import Api my_api_blueprint = Blueprint('api', __name__) API = Api( my_api_blueprint, title='My Microservice', version=current_app.config[\"APP_VERSION\"], description='Microservice to manage hierarchies', add_specs=True, ) This raises a 'working outside of application context error. Who can solve this problem? from flask import Blueprint, current_app from flask_restplus import Api from pyms.flask.app import config my_api_blueprint = Blueprint('api', __name__) API = Api( my_api_blueprint, title='My Microservice', version=config().APP_VERSION, description='Microservice to manage hierarchies', add_specs=True, )","title":"Import Configuration"},{"location":"configuration/#looking-for-configuration-file-with-kubernetes-configmaps","text":"By default, the Microservice class searches for a config.yml in the same path. You can set a different route or set a json file. To change this path, you must define an environment variable called PYMS_CONFIGMAP_FILE . This way of looking for the configuration is useful when you work with Docker and Kubernetes. For example, you could integrate a configmap of Kubernetes, with this microservice and a deployment with: apiVersion: extensions/v1beta1 kind: Deployment metadata: name: my-microservice spec: replicas: 1 template: spec: containers: - name: my-microservice image: ... env: - name: PYMS_CONFIGMAP_FILE value: \"/usr/share/microservice/config.yaml\" volumeMounts: - mountPath: /usr/share/microservice name: ms-config-volume volumes: - name: ms-config-volume configMap: name: my-microservice-configmap See Routing and Examples to continue with this tutorial","title":"Looking for Configuration file with Kubernetes Configmaps"},{"location":"configuration/#reload-configuration-without-stopping-your-services","text":"In a production environment you may need to change the microservice's configuration without restarting it. PyMS has a feature to reload the configuration: curl -X POST http://localhost:5000/reload-config This endpoint calls the method Microservice.reload_conf() , which restarts the services, the encryption configuration and initializes create_app . def reload_conf(self): self.delete_services() self.config.reload() self.services = [] self.init_services() self.crypt.config.reload() self.create_app() This means that your libraries will be restarted, which is why it's important to initialize your BD, your configuration inside init_libs method. See more info how to use Microservice class in this link","title":"Reload configuration without stopping your services"},{"location":"encrypt_decryt_configuration/","text":"Encrypt Configuration Configuration Method 1: Encrypt and decrypt with key file and Fernet When you work in multiple environments: local, dev, testing, production... you must set critical configuration in your variables, such as: config.yml, for local propose: pyms: config: DEBUG: true TESTING: true APPLICATION_ROOT : \"\" SECRET_KEY: \"gjr39dkjn344_!67#\" SQLALCHEMY_DATABASE_URI: mysql+mysqlconnector://user_of_db:user_of_db@localhost/my_schema config_pro.yml, for production environment: pyms: config: DEBUG: true TESTING: true APPLICATION_ROOT : \"\" SECRET_KEY: \"gjr39dkjn344_!67#\" SQLALCHEMY_DATABASE_URI: mysql+mysqlconnector://important_user:****@localhost/my_schema You can move this file to a Kubernetes secret , use Vault or encrypt the configuration with AWS KMS or Google KMS . We strongly recommend these way of encrypting/decrypting your configuration, but if you don't want a vendor locking option or you don't have the resources to use these methods, we provide a way to encrypt and decrypt your variables. 1. Generate a key PyMS has a command line option to create a key file. This key is created with AES . You can run the next command in the terminal: pyms create-key Then, type a password and it will create a file called key.key . This file contains a unique key. If you loose this file and re-run the create command, the key hash will be different and your code encrypted with this key won't be able to be decrypted. Store this key in a secure site, and DO NOT COMMIT it to your repository. 2. Add your key to your environment Move your key, for example, to mv key.key /home/my_user/keys/myproject.key then, store the key in a environment variable with: export PYMS_KEY_FILE=/home/my_user/keys/myproject.key 3. Encrypt your information and store it in config Do you remember the example file config_pro.yml ? Now you can encrypt and decrypt the information, you can run the command pyms encrypt [string] to generate a crypt string, for example: pyms encrypt 'mysql+mysqlconnector://important_user:****@localhost/my_schema' >> Encrypted OK: b'gAAAAABeSwBJv43hnGAWZOY50QjBX6uGLxUb3Q6fcUhMxKspIVIco8qwwZvxRg930uRlsd47isroXzkdRRnb4-x2dsQMp0dln8Pm2ySHH7TryLbQYEFbSh8RQK7zor-hX6gB-JY3uQD3IMtiVKx9AF95D6U4ydT-OA==' And store this string in your config_pro.yml : pyms: crypt: method: \"fernet\" config: DEBUG: true TESTING: true APPLICATION_ROOT : \"\" SECRET_KEY: \"gjr39dkjn344_!67#\" ENC_SQLALCHEMY_DATABASE_URI: gAAAAABeSwBJv43hnGAWZOY50QjBX6uGLxUb3Q6fcUhMxKspIVIco8qwwZvxRg930uRlsd47isroXzkdRRnb4-x2dsQMp0dln8Pm2ySHH7TryLbQYEFbSh8RQK7zor-hX6gB-JY3uQD3IMtiVKx9AF95D6U4ydT-OA== Do you see the difference between ENC_SQLALCHEMY_DATABASE_URI and SQLALCHEMY_DATABASE_URI ? In the next step you can find the answer 4. Decrypt from your config file Pyms knows if a variable is encrypted if this var start with the prefix enc_ or ENC_ . PyMS searches for your key file in the PYMS_KEY_FILE env variable and decrypts this value to store it in the same variable without the enc_ prefix, for example, ENC_SQLALCHEMY_DATABASE_URI: gAAAAABeSwBJv43hnGAWZOY50QjBX6uGLxUb3Q6fcUhMxKspIVIco8qwwZvxRg930uRlsd47isroXzkdRRnb4-x2dsQMp0dln8Pm2ySHH7TryLbQYEFbSh8RQK7zor-hX6gB-JY3uQD3IMtiVKx9AF95D6U4ydT-OA== Will be stored as SQLALCHEMY_DATABASE_URI: mysql+mysqlconnector://user_of_db:user_of_db@localhost/my_schema And you can access this var with current_app.config[\"SQLALCHEMY_DATABASE_URI\"] Method 2: Encrypt and decrypt with AWS KMS 1. Configure AWS Pyms knows if a variable is encrypted if this var start with the prefix enc_ or ENC_ . PyMS uses boto3 and aws cli to decrypt this value and store it in the same variable without the enc_ prefix. First, configure aws your aws account credentials: aws configure 2. Encrypt with KMS Cypher a string with this command: aws kms encrypt --key-id alias/prueba-avara --plaintext \"mysql+mysqlconnector://important_user:****@localhost/my_schema\" --query CiphertextBlob --output text >> AQICAHiALhLQv4eW8jqUccFSnkyDkBAWLAm97Lr2qmdItkUCIAF+P4u/uqzu8KRT74PsnQXhAAAAoDCBnQYJKoZIhvcNAQcGoIGPMIGMAgEAMIGGBgkqhkiG9w0BBwEwHgYJYIZIAWUDBAEuMBEEDPo+k3ZxoI9XVKtHgQIBEIBZmp7UUVjNWd6qKrLVK8oBNczY0CfLH6iAZE3UK5Ofs4+nZFi0PL3SEW8M15VgTpQoC/b0YxDPHjF0V6NHUJcWirSAqKkP5Sz5eSTk91FTuiwDpvYQ2q9aY6w= 3. Decrypt from your config file And put this string in your config_pro.yml : pyms: crypt: method: \"aws_kms\" key_id: \"alias/your-kms-key\" config: DEBUG: true TESTING: true APPLICATION_ROOT : \"\" SECRET_KEY: \"gjr39dkjn344_!67#\" ENC_SQLALCHEMY_DATABASE_URI: \"AQICAHiALhLQv4eW8jqUccFSnkyDkBAWLAm97Lr2qmdItkUCIAF+P4u/uqzu8KRT74PsnQXhAAAAoDCBnQYJKoZIhvcNAQcGoIGPMIGMAgEAMIGGBgkqhkiG9w0BBwEwHgYJYIZIAWUDBAEuMBEEDPo+k3ZxoI9XVKtHgQIBEIBZmp7UUVjNWd6qKrLVK8oBNczY0CfLH6iAZE3UK5Ofs4+nZFi0PL3SEW8M15VgTpQoC/b0YxDPHjF0V6NHUJcWirSAqKkP5Sz5eSTk91FTuiwDpvYQ2q9aY6w= \"","title":"Encrypt/Decrypt Configuration"},{"location":"encrypt_decryt_configuration/#encrypt-configuration","text":"","title":"Encrypt Configuration"},{"location":"encrypt_decryt_configuration/#configuration","text":"","title":"Configuration"},{"location":"encrypt_decryt_configuration/#method-1-encrypt-and-decrypt-with-key-file-and-fernet","text":"When you work in multiple environments: local, dev, testing, production... you must set critical configuration in your variables, such as: config.yml, for local propose: pyms: config: DEBUG: true TESTING: true APPLICATION_ROOT : \"\" SECRET_KEY: \"gjr39dkjn344_!67#\" SQLALCHEMY_DATABASE_URI: mysql+mysqlconnector://user_of_db:user_of_db@localhost/my_schema config_pro.yml, for production environment: pyms: config: DEBUG: true TESTING: true APPLICATION_ROOT : \"\" SECRET_KEY: \"gjr39dkjn344_!67#\" SQLALCHEMY_DATABASE_URI: mysql+mysqlconnector://important_user:****@localhost/my_schema You can move this file to a Kubernetes secret , use Vault or encrypt the configuration with AWS KMS or Google KMS . We strongly recommend these way of encrypting/decrypting your configuration, but if you don't want a vendor locking option or you don't have the resources to use these methods, we provide a way to encrypt and decrypt your variables.","title":"Method 1: Encrypt and decrypt with key file and Fernet"},{"location":"encrypt_decryt_configuration/#1-generate-a-key","text":"PyMS has a command line option to create a key file. This key is created with AES . You can run the next command in the terminal: pyms create-key Then, type a password and it will create a file called key.key . This file contains a unique key. If you loose this file and re-run the create command, the key hash will be different and your code encrypted with this key won't be able to be decrypted. Store this key in a secure site, and DO NOT COMMIT it to your repository.","title":"1. Generate a key"},{"location":"encrypt_decryt_configuration/#2-add-your-key-to-your-environment","text":"Move your key, for example, to mv key.key /home/my_user/keys/myproject.key then, store the key in a environment variable with: export PYMS_KEY_FILE=/home/my_user/keys/myproject.key","title":"2. Add your key to your environment"},{"location":"encrypt_decryt_configuration/#3-encrypt-your-information-and-store-it-in-config","text":"Do you remember the example file config_pro.yml ? Now you can encrypt and decrypt the information, you can run the command pyms encrypt [string] to generate a crypt string, for example: pyms encrypt 'mysql+mysqlconnector://important_user:****@localhost/my_schema' >> Encrypted OK: b'gAAAAABeSwBJv43hnGAWZOY50QjBX6uGLxUb3Q6fcUhMxKspIVIco8qwwZvxRg930uRlsd47isroXzkdRRnb4-x2dsQMp0dln8Pm2ySHH7TryLbQYEFbSh8RQK7zor-hX6gB-JY3uQD3IMtiVKx9AF95D6U4ydT-OA==' And store this string in your config_pro.yml : pyms: crypt: method: \"fernet\" config: DEBUG: true TESTING: true APPLICATION_ROOT : \"\" SECRET_KEY: \"gjr39dkjn344_!67#\" ENC_SQLALCHEMY_DATABASE_URI: gAAAAABeSwBJv43hnGAWZOY50QjBX6uGLxUb3Q6fcUhMxKspIVIco8qwwZvxRg930uRlsd47isroXzkdRRnb4-x2dsQMp0dln8Pm2ySHH7TryLbQYEFbSh8RQK7zor-hX6gB-JY3uQD3IMtiVKx9AF95D6U4ydT-OA== Do you see the difference between ENC_SQLALCHEMY_DATABASE_URI and SQLALCHEMY_DATABASE_URI ? In the next step you can find the answer","title":"3. Encrypt your information and store it in config"},{"location":"encrypt_decryt_configuration/#4-decrypt-from-your-config-file","text":"Pyms knows if a variable is encrypted if this var start with the prefix enc_ or ENC_ . PyMS searches for your key file in the PYMS_KEY_FILE env variable and decrypts this value to store it in the same variable without the enc_ prefix, for example, ENC_SQLALCHEMY_DATABASE_URI: gAAAAABeSwBJv43hnGAWZOY50QjBX6uGLxUb3Q6fcUhMxKspIVIco8qwwZvxRg930uRlsd47isroXzkdRRnb4-x2dsQMp0dln8Pm2ySHH7TryLbQYEFbSh8RQK7zor-hX6gB-JY3uQD3IMtiVKx9AF95D6U4ydT-OA== Will be stored as SQLALCHEMY_DATABASE_URI: mysql+mysqlconnector://user_of_db:user_of_db@localhost/my_schema And you can access this var with current_app.config[\"SQLALCHEMY_DATABASE_URI\"]","title":"4. Decrypt from your config file"},{"location":"encrypt_decryt_configuration/#method-2-encrypt-and-decrypt-with-aws-kms","text":"","title":"Method 2: Encrypt and decrypt with AWS KMS"},{"location":"encrypt_decryt_configuration/#1-configure-aws","text":"Pyms knows if a variable is encrypted if this var start with the prefix enc_ or ENC_ . PyMS uses boto3 and aws cli to decrypt this value and store it in the same variable without the enc_ prefix. First, configure aws your aws account credentials: aws configure","title":"1. Configure AWS"},{"location":"encrypt_decryt_configuration/#2-encrypt-with-kms","text":"Cypher a string with this command: aws kms encrypt --key-id alias/prueba-avara --plaintext \"mysql+mysqlconnector://important_user:****@localhost/my_schema\" --query CiphertextBlob --output text >> AQICAHiALhLQv4eW8jqUccFSnkyDkBAWLAm97Lr2qmdItkUCIAF+P4u/uqzu8KRT74PsnQXhAAAAoDCBnQYJKoZIhvcNAQcGoIGPMIGMAgEAMIGGBgkqhkiG9w0BBwEwHgYJYIZIAWUDBAEuMBEEDPo+k3ZxoI9XVKtHgQIBEIBZmp7UUVjNWd6qKrLVK8oBNczY0CfLH6iAZE3UK5Ofs4+nZFi0PL3SEW8M15VgTpQoC/b0YxDPHjF0V6NHUJcWirSAqKkP5Sz5eSTk91FTuiwDpvYQ2q9aY6w=","title":"2. Encrypt with KMS"},{"location":"encrypt_decryt_configuration/#3-decrypt-from-your-config-file","text":"And put this string in your config_pro.yml : pyms: crypt: method: \"aws_kms\" key_id: \"alias/your-kms-key\" config: DEBUG: true TESTING: true APPLICATION_ROOT : \"\" SECRET_KEY: \"gjr39dkjn344_!67#\" ENC_SQLALCHEMY_DATABASE_URI: \"AQICAHiALhLQv4eW8jqUccFSnkyDkBAWLAm97Lr2qmdItkUCIAF+P4u/uqzu8KRT74PsnQXhAAAAoDCBnQYJKoZIhvcNAQcGoIGPMIGMAgEAMIGGBgkqhkiG9w0BBwEwHgYJYIZIAWUDBAEuMBEEDPo+k3ZxoI9XVKtHgQIBEIBZmp7UUVjNWd6qKrLVK8oBNczY0CfLH6iAZE3UK5Ofs4+nZFi0PL3SEW8M15VgTpQoC/b0YxDPHjF0V6NHUJcWirSAqKkP5Sz5eSTk91FTuiwDpvYQ2q9aY6w= \"","title":"3. Decrypt from your config file"},{"location":"hacktoberfest_es_2020/","text":"HacktoberfestES 2020 This article is a review of the event Python HacktoberfestES [2020-10-04] Presentaci\u00f3n Hacktoberfest v\u00eddeo inaugural Presentaci\u00f3n [2020-10-04] Presentaci\u00f3n PyMS Buenas! Con PyMS vamos a estudiar y aprender a construir microservicios para el mundo real: No solo una API que devuelve datos. \u00bfqu\u00e9 tiene que cumplir un microservicio para ser productivo? Configuraci\u00f3n externalizada, healthchecks, trazabilidad... \u00a1y mucho m\u00e1s! Puedes ver la documentaci\u00f3n en este link Ver el c\u00f3digo fuente en Github al igual que las issues abiertas (y las que se nos vayan ocurriendo) Puedes clonarte un arquetipo de microservicio funcional O crearte el tuyo propio con Cookiecutter : [2020-10-04] Hacktoberfest: primera reuni\u00f3n De los que hemos participado juntamos un stack tecnol\u00f3gico muy interesante habiendo tocado no solo Python si no lenguajes como Java, .NET, Groovy, BASH, Ruby, adem\u00e1s de tecnolog\u00edas blockchain, sistemas e infrastructura, CI... Tambi\u00e9n hemos visto que PyMS, tanto la librer\u00eda como el arquetipo \"destacado\" son sobre Flask pero puede incluir en un futuro otros frameworks como aiohttp o FastAPI. Pero adem\u00e1s existe este proyecto para adaptar todas estas buenas pr\u00e1cticas sobre un proyecto de Django. Planteamos, si a alguien no le atraen los microservicios como tal, poder crear una p\u00e1gina web est\u00e1tica con la documentaci\u00f3n, informaci\u00f3n y literatura sobre microservicios y quien sabe, hasta un posible blog con un generador de contenido est\u00e1tico como Nikola o alguno de estos (pendiente de definir) Como no todos tenemos el mismo nivel, hemos acordado empezar con unos tutoriales y formaciones en Python y el arquetipo para tener todos contexto y el fin de semana que viene hacer puesta en com\u00fan y empezar a trabajar sobre issues de los proyectos. Para poder colaborar, proponemos que cuando alguien est\u00e9 mirando cosas del proyecto o dedicado a investigar, que avise por chat y si quiere, conectarse al chat de voz para resolver dudas y hacer pair-programming, presentar o charlar. Del mismo modo, si alguien quiere ver dudas que avise por chat \"a tal hora me conecto\" Recursos \u00fatiles para aprender Python: 7 Repositorios para aprender Python Cursos, Posts y Podcasts realpython.com - Python en general, cursos pago, posts gratis, muy claro. www.fullstackpython.com - Posts de desarrollo fullstack, muchos enlaces a otros recursos. training.talkpython.fm - Podcast gratis y cursos de pago, mucho de web en Flask. www.pluralsight.com - De pago, muchos lenguajes, mucho testing, muchos perfiles (dev, sec, devops), buenos recursos video, examenes, portfolio de habilidades y roles. ed.team - Canal de youtube, cursos de pago, muchas tecnolog\u00edas, en espa\u00f1ol. codely.tv - Canal de youtube, cursos de pago (devops y arquitectura), algo de Golang pero nada de Python Katas www.hackerrank.com muchos niveles, portfolio de habilidades, bolsa de trabajo. exercism.io - muchos lenguajes, basado en tests, editas offline y envias con terminal. www.codewars.com - muchos lenguajes, plataforma de katas, con katas de usuario. Noticias dev.to/t/python - Noticias y dudas. www.reddit.com/r/Python - Noticias, dudas y nido de trolls. Aprender Jugando www.codingame.com - Muchos lenguajes. py.checkio.org www.twilio.com/quest - Gracioso pero poco codigo. Relacionadas con PyMS: Forma m\u00e1s actual de hacer tests en python: docs.pytest.org/en/stable Para complementar tus test, Tox: tox.readthedocs.io/en/latest Pipenv como sustituto del t\u00edpico virtualenv: pipenv-es.readthedocs.io/es/latest Linter para verificar la sintaxis del c\u00f3digo, Pylint: pylint.readthedocs.io/en/latest/?badge=latest Tambi\u00e9n Flake8: flake8.pycqa.org/en/latest \"Tipado\" en Python: docs.python.org/3/library/typing.html \"La biblia\" de la arquitectura de microservicios: microservices.io Trazabilidad distribuida con Python: github.com/opentracing/opentracing-python [2020-10-05] Formaci\u00f3n, Python B\u00e1sico: Ver repositorio [2020-10-06] Formaci\u00f3n, buenas pr\u00e1cticas: Ver repositorio [2020-10-08] Formaci\u00f3n, C\u00f3mo funciona PyMS: Ver v\u00eddeo [2020-10-08] Formaci\u00f3n, Portainer, web-ui para manejar Docker: Ver v\u00eddeo [2020-10-09] Fin de sprint, reparto de tareas: Se puede contribuir mediante Fork o avisadme y os a\u00f1ado como colaboradores para poder trabajar sobre el mismo repo. Lo que prefir\u00e1is! Para el flujo de ramas, ver workflow para contribuir Para los mensajes de commit ver: Conventional Commits Al igual que Angular guideline Tareas/issues repartidas: PyMS Issue #166 @BelenC y @AmandaKhol -> En esta pueden participar m\u00e1s de una persona PyMS Issue #89 @Rapejim Microservices-scaffold Issue #213 @vmyelicich PyMS Issue #178 @kirk Microservices-scaffold Issue #215 @felipem775 github.com/python-microservices/cookiecutter-pyms/issues/9 @AmandaKhol github.com/python-microservices/cookiecutter-pyms/issues/4 @PandyTheBroh Tareas/issues listas para asignar: PyMS Issue #68 PyMS Issue #180 PyMS Issue #182 PyMS Issue #184 PyMS Issue #188 PyMS Issue #189 PyMS Issue #185 (HARD) PyMS Issue #156 (HARD) PyMS Issue #186 (HARD) PyMS Issue #190 (HARD) Investigaci\u00f3n: Access token: Investigar microservices.io/patterns/security/access-token.html Actualizar el repositorio de ejemplo con lo \u00faltimo de PyMS Mejorar y hacer de manera gen\u00e9rica la implementaci\u00f3n de JWT Saga: Investigar microservices.io/patterns/data/saga.html Crear un arquetipo parecido al que ya existe que haga este patr\u00f3n Circuit Breaker: Investigar microservices.io/patterns/reliability/circuit-breaker.html Llevar a PyMS, si es posible, ese patr\u00f3n para que se pueda usar en todos los microservicios (por ejemplo, como hace https://micronaut.io/) gRCP ( protocol buffers ): Una forma alternativa a API Rest para comunicar microservicios es mediante gRCP Crear un arquetipo parecido al que ya existe que se comunique con otro mediante gRCP Llevar a PyMS, si es posible, este framework Retos: Publisher-subscriber: github.com/python-microservices/pyms/issues/155 Crear un script que escuche y escriba en una cola infinitamente Evolucionar el servicio para que en un futuro se puedan ir a\u00f1adiendo diferentes servicios (SQS, Kafka, Pub/sub, RabbitMQ...) Meter este servicio en un subproceso/thread para que se pueda integrar con PyMS A\u00f1adir endpoints para consultar informaci\u00f3n de la cola Consejos y acuerdos: Hay que visitar Valpara\u00edso (Chile) Es necesario visitar la isla de La Palma al menos una vez en la vida Cuidado al pedir pizza a domicilio [2020-10-10] Debate sobre issue #89: Ver v\u00eddeo [2020-10-11] Resumen de la primera semana: Ver v\u00eddeo [2020-10-11] Git workflow y testing: TODO: falta link [2020-10-16] Fin de sprint, reparto de tareas: Dejamos asignadas tareas para todo el mundo para hacer el reto de hacktoberfest y que de aqu\u00ed a 2 semanas nadie nos quite alguna tarea que ten\u00edamos pensada Tareas/issues repartidas: PyMS Issue #189 @AmandaKhol PyMS Issue #196 @PandyTheBroh PyMS Issue #164 @Rapejim PyMS Issue #180 @mbcaldeiro Microservices-scaffold Issue #219 @mbcaldeiro PyMS Issue #184 @vmyelicich Microservices-scaffold Issue #220 @PandyTheBroh PyMS Issue #197 @PandyTheBroh Tareas/issues listas para asignar: Microservices-scaffold Issue #219 \u00bf@felipem775? Microservices-scaffold Issue #218 \u00bf@felipem775? PyMS Issue #195 PyMS Issue #188 PyMS Issue #68 PyMS Issue #182 PyMS Issue #199 [2020-10-23] Fin de sprint, lanzamiento de release, preparando el final: Vimos como publicar una librer\u00eda en https://pypi.org/, adem\u00e1s de tagear en github la nueva release : Tambi\u00e9n empezamos a hablar del cierre del hacktoberfest el pr\u00f3ximo domingo d\u00eda 1. Por lo que todo empuj\u00f3n que podamos dar esta semana para cumplir el reto y los hitos que nos marcamos, no dud\u00e9is en pedir ayuda por discord! Adicionalmente, hay que preparar una presentaci\u00f3n de cierre pues contando que hemos hecho y tal, entre los datos tenemos por ahora: * python-microservices/cookiecutter-pyms -> 2 PRs merged * python-microservices/microservices-chat -> 3 PRs merged * python-microservices/microservices-scaffold -> 7 PRs merged * python-microservices/pyms -> 7 PRs merged A todos los que hab\u00e9is participado, @Rapejim (Ra\u00fal) @BelenC @AmandaKhol @vmyelicich (V\u00edctor) @PandyTheBroh @felipem775 @kirk si quer\u00e9is participar y contar la experiencia, que os ha parecido el evento, el proyecto, el grupo... \u00a1bienvenido! \u00bfque que quer\u00e9is ponerlo por escrito en un par de frases? \u00a1tambi\u00e9n bien! [2020-10-30] Preparar el evento de cierre y la presentaci\u00f3n [2020-11-01] Cierre del HacktoberfestES 2020: Ver v\u00eddeo","title":"HacktoberfestES"},{"location":"hacktoberfest_es_2020/#hacktoberfestes-2020","text":"This article is a review of the event Python HacktoberfestES","title":"HacktoberfestES 2020"},{"location":"hacktoberfest_es_2020/#2020-10-04-presentacion-hacktoberfest","text":"v\u00eddeo inaugural Presentaci\u00f3n","title":"[2020-10-04] Presentaci\u00f3n Hacktoberfest"},{"location":"hacktoberfest_es_2020/#2020-10-04-presentacion-pyms","text":"Buenas! Con PyMS vamos a estudiar y aprender a construir microservicios para el mundo real: No solo una API que devuelve datos. \u00bfqu\u00e9 tiene que cumplir un microservicio para ser productivo? Configuraci\u00f3n externalizada, healthchecks, trazabilidad... \u00a1y mucho m\u00e1s! Puedes ver la documentaci\u00f3n en este link Ver el c\u00f3digo fuente en Github al igual que las issues abiertas (y las que se nos vayan ocurriendo) Puedes clonarte un arquetipo de microservicio funcional O crearte el tuyo propio con Cookiecutter :","title":"[2020-10-04] Presentaci\u00f3n PyMS"},{"location":"hacktoberfest_es_2020/#2020-10-04-hacktoberfest-primera-reunion","text":"De los que hemos participado juntamos un stack tecnol\u00f3gico muy interesante habiendo tocado no solo Python si no lenguajes como Java, .NET, Groovy, BASH, Ruby, adem\u00e1s de tecnolog\u00edas blockchain, sistemas e infrastructura, CI... Tambi\u00e9n hemos visto que PyMS, tanto la librer\u00eda como el arquetipo \"destacado\" son sobre Flask pero puede incluir en un futuro otros frameworks como aiohttp o FastAPI. Pero adem\u00e1s existe este proyecto para adaptar todas estas buenas pr\u00e1cticas sobre un proyecto de Django. Planteamos, si a alguien no le atraen los microservicios como tal, poder crear una p\u00e1gina web est\u00e1tica con la documentaci\u00f3n, informaci\u00f3n y literatura sobre microservicios y quien sabe, hasta un posible blog con un generador de contenido est\u00e1tico como Nikola o alguno de estos (pendiente de definir) Como no todos tenemos el mismo nivel, hemos acordado empezar con unos tutoriales y formaciones en Python y el arquetipo para tener todos contexto y el fin de semana que viene hacer puesta en com\u00fan y empezar a trabajar sobre issues de los proyectos. Para poder colaborar, proponemos que cuando alguien est\u00e9 mirando cosas del proyecto o dedicado a investigar, que avise por chat y si quiere, conectarse al chat de voz para resolver dudas y hacer pair-programming, presentar o charlar. Del mismo modo, si alguien quiere ver dudas que avise por chat \"a tal hora me conecto\"","title":"[2020-10-04] Hacktoberfest: primera reuni\u00f3n"},{"location":"hacktoberfest_es_2020/#recursos-utiles-para-aprender-python","text":"7 Repositorios para aprender Python","title":"Recursos \u00fatiles para aprender Python:"},{"location":"hacktoberfest_es_2020/#cursos-posts-y-podcasts","text":"realpython.com - Python en general, cursos pago, posts gratis, muy claro. www.fullstackpython.com - Posts de desarrollo fullstack, muchos enlaces a otros recursos. training.talkpython.fm - Podcast gratis y cursos de pago, mucho de web en Flask. www.pluralsight.com - De pago, muchos lenguajes, mucho testing, muchos perfiles (dev, sec, devops), buenos recursos video, examenes, portfolio de habilidades y roles. ed.team - Canal de youtube, cursos de pago, muchas tecnolog\u00edas, en espa\u00f1ol. codely.tv - Canal de youtube, cursos de pago (devops y arquitectura), algo de Golang pero nada de Python","title":"Cursos, Posts y Podcasts"},{"location":"hacktoberfest_es_2020/#katas","text":"www.hackerrank.com muchos niveles, portfolio de habilidades, bolsa de trabajo. exercism.io - muchos lenguajes, basado en tests, editas offline y envias con terminal. www.codewars.com - muchos lenguajes, plataforma de katas, con katas de usuario.","title":"Katas"},{"location":"hacktoberfest_es_2020/#noticias","text":"dev.to/t/python - Noticias y dudas. www.reddit.com/r/Python - Noticias, dudas y nido de trolls.","title":"Noticias"},{"location":"hacktoberfest_es_2020/#aprender-jugando","text":"www.codingame.com - Muchos lenguajes. py.checkio.org www.twilio.com/quest - Gracioso pero poco codigo.","title":"Aprender Jugando"},{"location":"hacktoberfest_es_2020/#relacionadas-con-pyms","text":"Forma m\u00e1s actual de hacer tests en python: docs.pytest.org/en/stable Para complementar tus test, Tox: tox.readthedocs.io/en/latest Pipenv como sustituto del t\u00edpico virtualenv: pipenv-es.readthedocs.io/es/latest Linter para verificar la sintaxis del c\u00f3digo, Pylint: pylint.readthedocs.io/en/latest/?badge=latest Tambi\u00e9n Flake8: flake8.pycqa.org/en/latest \"Tipado\" en Python: docs.python.org/3/library/typing.html \"La biblia\" de la arquitectura de microservicios: microservices.io Trazabilidad distribuida con Python: github.com/opentracing/opentracing-python","title":"Relacionadas con PyMS:"},{"location":"hacktoberfest_es_2020/#2020-10-05-formacion-python-basico","text":"Ver repositorio","title":"[2020-10-05] Formaci\u00f3n, Python B\u00e1sico:"},{"location":"hacktoberfest_es_2020/#2020-10-06-formacion-buenas-practicas","text":"Ver repositorio","title":"[2020-10-06] Formaci\u00f3n, buenas pr\u00e1cticas:"},{"location":"hacktoberfest_es_2020/#2020-10-08-formacion-como-funciona-pyms","text":"Ver v\u00eddeo","title":"[2020-10-08] Formaci\u00f3n, C\u00f3mo funciona PyMS:"},{"location":"hacktoberfest_es_2020/#2020-10-08-formacion-portainer-web-ui-para-manejar-docker","text":"Ver v\u00eddeo","title":"[2020-10-08] Formaci\u00f3n, Portainer, web-ui para manejar Docker:"},{"location":"hacktoberfest_es_2020/#2020-10-09-fin-de-sprint-reparto-de-tareas","text":"Se puede contribuir mediante Fork o avisadme y os a\u00f1ado como colaboradores para poder trabajar sobre el mismo repo. Lo que prefir\u00e1is! Para el flujo de ramas, ver workflow para contribuir Para los mensajes de commit ver: Conventional Commits Al igual que Angular guideline","title":"[2020-10-09] Fin de sprint, reparto de tareas:"},{"location":"hacktoberfest_es_2020/#tareasissues-repartidas","text":"PyMS Issue #166 @BelenC y @AmandaKhol -> En esta pueden participar m\u00e1s de una persona PyMS Issue #89 @Rapejim Microservices-scaffold Issue #213 @vmyelicich PyMS Issue #178 @kirk Microservices-scaffold Issue #215 @felipem775 github.com/python-microservices/cookiecutter-pyms/issues/9 @AmandaKhol github.com/python-microservices/cookiecutter-pyms/issues/4 @PandyTheBroh","title":"Tareas/issues repartidas:"},{"location":"hacktoberfest_es_2020/#tareasissues-listas-para-asignar","text":"PyMS Issue #68 PyMS Issue #180 PyMS Issue #182 PyMS Issue #184 PyMS Issue #188 PyMS Issue #189 PyMS Issue #185 (HARD) PyMS Issue #156 (HARD) PyMS Issue #186 (HARD) PyMS Issue #190 (HARD)","title":"Tareas/issues listas para asignar:"},{"location":"hacktoberfest_es_2020/#investigacion","text":"Access token: Investigar microservices.io/patterns/security/access-token.html Actualizar el repositorio de ejemplo con lo \u00faltimo de PyMS Mejorar y hacer de manera gen\u00e9rica la implementaci\u00f3n de JWT Saga: Investigar microservices.io/patterns/data/saga.html Crear un arquetipo parecido al que ya existe que haga este patr\u00f3n Circuit Breaker: Investigar microservices.io/patterns/reliability/circuit-breaker.html Llevar a PyMS, si es posible, ese patr\u00f3n para que se pueda usar en todos los microservicios (por ejemplo, como hace https://micronaut.io/) gRCP ( protocol buffers ): Una forma alternativa a API Rest para comunicar microservicios es mediante gRCP Crear un arquetipo parecido al que ya existe que se comunique con otro mediante gRCP Llevar a PyMS, si es posible, este framework","title":"Investigaci\u00f3n:"},{"location":"hacktoberfest_es_2020/#retos","text":"Publisher-subscriber: github.com/python-microservices/pyms/issues/155 Crear un script que escuche y escriba en una cola infinitamente Evolucionar el servicio para que en un futuro se puedan ir a\u00f1adiendo diferentes servicios (SQS, Kafka, Pub/sub, RabbitMQ...) Meter este servicio en un subproceso/thread para que se pueda integrar con PyMS A\u00f1adir endpoints para consultar informaci\u00f3n de la cola","title":"Retos:"},{"location":"hacktoberfest_es_2020/#consejos-y-acuerdos","text":"Hay que visitar Valpara\u00edso (Chile) Es necesario visitar la isla de La Palma al menos una vez en la vida Cuidado al pedir pizza a domicilio","title":"Consejos y acuerdos:"},{"location":"hacktoberfest_es_2020/#2020-10-10-debate-sobre-issue-89","text":"Ver v\u00eddeo","title":"[2020-10-10] Debate sobre issue #89:"},{"location":"hacktoberfest_es_2020/#2020-10-11-resumen-de-la-primera-semana","text":"Ver v\u00eddeo","title":"[2020-10-11] Resumen de la primera semana:"},{"location":"hacktoberfest_es_2020/#2020-10-11-git-workflow-y-testing","text":"TODO: falta link","title":"[2020-10-11] Git workflow y testing:"},{"location":"hacktoberfest_es_2020/#2020-10-16-fin-de-sprint-reparto-de-tareas","text":"Dejamos asignadas tareas para todo el mundo para hacer el reto de hacktoberfest y que de aqu\u00ed a 2 semanas nadie nos quite alguna tarea que ten\u00edamos pensada","title":"[2020-10-16] Fin de sprint, reparto de tareas:"},{"location":"hacktoberfest_es_2020/#tareasissues-repartidas_1","text":"PyMS Issue #189 @AmandaKhol PyMS Issue #196 @PandyTheBroh PyMS Issue #164 @Rapejim PyMS Issue #180 @mbcaldeiro Microservices-scaffold Issue #219 @mbcaldeiro PyMS Issue #184 @vmyelicich Microservices-scaffold Issue #220 @PandyTheBroh PyMS Issue #197 @PandyTheBroh","title":"Tareas/issues repartidas:"},{"location":"hacktoberfest_es_2020/#tareasissues-listas-para-asignar_1","text":"Microservices-scaffold Issue #219 \u00bf@felipem775? Microservices-scaffold Issue #218 \u00bf@felipem775? PyMS Issue #195 PyMS Issue #188 PyMS Issue #68 PyMS Issue #182 PyMS Issue #199","title":"Tareas/issues listas para asignar:"},{"location":"hacktoberfest_es_2020/#2020-10-23-fin-de-sprint-lanzamiento-de-release-preparando-el-final","text":"Vimos como publicar una librer\u00eda en https://pypi.org/, adem\u00e1s de tagear en github la nueva release : Tambi\u00e9n empezamos a hablar del cierre del hacktoberfest el pr\u00f3ximo domingo d\u00eda 1. Por lo que todo empuj\u00f3n que podamos dar esta semana para cumplir el reto y los hitos que nos marcamos, no dud\u00e9is en pedir ayuda por discord! Adicionalmente, hay que preparar una presentaci\u00f3n de cierre pues contando que hemos hecho y tal, entre los datos tenemos por ahora: * python-microservices/cookiecutter-pyms -> 2 PRs merged * python-microservices/microservices-chat -> 3 PRs merged * python-microservices/microservices-scaffold -> 7 PRs merged * python-microservices/pyms -> 7 PRs merged A todos los que hab\u00e9is participado, @Rapejim (Ra\u00fal) @BelenC @AmandaKhol @vmyelicich (V\u00edctor) @PandyTheBroh @felipem775 @kirk si quer\u00e9is participar y contar la experiencia, que os ha parecido el evento, el proyecto, el grupo... \u00a1bienvenido! \u00bfque que quer\u00e9is ponerlo por escrito en un par de frases? \u00a1tambi\u00e9n bien!","title":"[2020-10-23] Fin de sprint, lanzamiento de release, preparando el final:"},{"location":"hacktoberfest_es_2020/#2020-10-30-preparar-el-evento-de-cierre-y-la-presentacion","text":"","title":"[2020-10-30] Preparar el evento de cierre y la presentaci\u00f3n"},{"location":"hacktoberfest_es_2020/#2020-11-01-cierre-del-hacktoberfestes-2020","text":"Ver v\u00eddeo","title":"[2020-11-01] Cierre del HacktoberfestES 2020:"},{"location":"home/","text":"Welcome to PyMS PyMS, Python MicroService, is a Microservice chassis pattern like Spring Boot (Java) or Gizmo (Golang). PyMS is a collection of libraries, best practices and recommended ways to build microservices with Python which handles cross-cutting concerns: Externalized configuration Logging Health checks Metrics Distributed tracing PyMS is powered by Flask , Connexion and Opentracing . Get started with an Introduction to Microservices in English or Spanish and then the Installation . Get an overview with the Quickstart . Motivation When we started to create a microservice with no previous knowledge, we started looking for tutorials, guides, best practices, but we found nothing to create professional projects. Most articles say: \"Install flask\" \"Create routes\" (Sometimes) \"Create a swagger specs\" \"TA-DA! you have a microservice\" But... what happens when we want our configuration out of the code, such as a Kubernetes configmap? what happens with transactionality? If we have many microservices, what happens with traces?. There are many problems around Python and microservices and we couldn't find anyone to give us a solution. We start creating these projects to try to solve all the problems we have found in our professional lives about microservices architecture. Nowadays, is not perfect and we have a looong roadmap, but we hope this library could help other felas and friends ;)","title":"Home"},{"location":"home/#welcome-to-pyms","text":"PyMS, Python MicroService, is a Microservice chassis pattern like Spring Boot (Java) or Gizmo (Golang). PyMS is a collection of libraries, best practices and recommended ways to build microservices with Python which handles cross-cutting concerns: Externalized configuration Logging Health checks Metrics Distributed tracing PyMS is powered by Flask , Connexion and Opentracing . Get started with an Introduction to Microservices in English or Spanish and then the Installation . Get an overview with the Quickstart .","title":"Welcome to PyMS"},{"location":"home/#motivation","text":"When we started to create a microservice with no previous knowledge, we started looking for tutorials, guides, best practices, but we found nothing to create professional projects. Most articles say: \"Install flask\" \"Create routes\" (Sometimes) \"Create a swagger specs\" \"TA-DA! you have a microservice\" But... what happens when we want our configuration out of the code, such as a Kubernetes configmap? what happens with transactionality? If we have many microservices, what happens with traces?. There are many problems around Python and microservices and we couldn't find anyone to give us a solution. We start creating these projects to try to solve all the problems we have found in our professional lives about microservices architecture. Nowadays, is not perfect and we have a looong roadmap, but we hope this library could help other felas and friends ;)","title":"Motivation"},{"location":"installation/","text":"Installation Python Version We recommend using the latest version of Python 3. PyMS supports Python 3.6 and newer and PyPy. Install PyMS Installing pyms with all dependencies pip install py-ms[all] Installing minimun dependencies pip install py-ms Installing request dependencies pip install py-ms[request] Installing swagger dependencies pip install py-ms[swagger] Installing metrics dependencies pip install py-ms[metrics] Installing trace dependencies pip install py-ms[trace] Install with virtualenv and requirements.txt Create a virtualenv virtualenv --python=python[3.6|3.7|3.8] venv source venv/bin/activate Add in your requirements.txt: py-ms[all|metrics|trace]==[VERSION] In example: py-ms[all]>=2.7.0 and then install with pip install -r requirements.txt Install with pipenv and Pipfile Create a pipenv environment pipenv install Or install PyMS with the command: pipenv install py-ms[all]>=2.7.0 Or add PyMS in your Pipfile: [[source]] name = \"pypi\" url = \"https://pypi.org/simple\" verify_ssl = true [dev-packages] [packages] py-ms = {extras = [\"all\"],version = \"==2.6.1\"} Next Steps See Quickstart to continue with this tutorial","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#python-version","text":"We recommend using the latest version of Python 3. PyMS supports Python 3.6 and newer and PyPy.","title":"Python Version"},{"location":"installation/#install-pyms","text":"Installing pyms with all dependencies pip install py-ms[all] Installing minimun dependencies pip install py-ms Installing request dependencies pip install py-ms[request] Installing swagger dependencies pip install py-ms[swagger] Installing metrics dependencies pip install py-ms[metrics] Installing trace dependencies pip install py-ms[trace]","title":"Install PyMS"},{"location":"installation/#install-with-virtualenv-and-requirementstxt","text":"Create a virtualenv virtualenv --python=python[3.6|3.7|3.8] venv source venv/bin/activate Add in your requirements.txt: py-ms[all|metrics|trace]==[VERSION] In example: py-ms[all]>=2.7.0 and then install with pip install -r requirements.txt","title":"Install with virtualenv and requirements.txt"},{"location":"installation/#install-with-pipenv-and-pipfile","text":"Create a pipenv environment pipenv install Or install PyMS with the command: pipenv install py-ms[all]>=2.7.0 Or add PyMS in your Pipfile: [[source]] name = \"pypi\" url = \"https://pypi.org/simple\" verify_ssl = true [dev-packages] [packages] py-ms = {extras = [\"all\"],version = \"==2.6.1\"}","title":"Install with pipenv and Pipfile"},{"location":"installation/#next-steps","text":"See Quickstart to continue with this tutorial","title":"Next Steps"},{"location":"links_articles/","text":"External Links and Articles Articles English Create the Python Microservice with pyms Spanish \u00bfC\u00f3mo construir microservicios en Python? (1/2) Microservice Chassis Pattern en Python, historia de un sue\u00f1o Open Source (2/2) Divide y Vencer\u00e1s Podcasts Spanish Microservicios y Python","title":"External Links and Articles"},{"location":"links_articles/#external-links-and-articles","text":"","title":"External Links and Articles"},{"location":"links_articles/#articles","text":"","title":"Articles"},{"location":"links_articles/#english","text":"Create the Python Microservice with pyms","title":"English"},{"location":"links_articles/#spanish","text":"\u00bfC\u00f3mo construir microservicios en Python? (1/2) Microservice Chassis Pattern en Python, historia de un sue\u00f1o Open Source (2/2) Divide y Vencer\u00e1s","title":"Spanish"},{"location":"links_articles/#podcasts","text":"","title":"Podcasts"},{"location":"links_articles/#spanish_1","text":"Microservicios y Python","title":"Spanish"},{"location":"microservices/","text":"Introduction to Microservices Typically, the application structure is based on a monolithic architecture scheme. In this architecture, all the elements implemented are included in a single application. The monolithic architecture has some disadvantages, such as it becomes more difficult to solve problems and add new functionalities as the application grows. The microservicies architecture pattern is proposed in order to solve these problems. Figure 1: Microservice vs Monolith architecture. Source: Martin Fowler What are the microservices? Microservices - also known as the microservice architecture - structures an application as a collection of services. The idea is to split the application into a set of smaller, interconnected services instead of building a single monolithic application. Thus, each microservice is a small application. Ideally, a microservice or service has to be specialized in solving the problems of a single domain using the best available technology. In addition, each service must have an API in order to facilitate communication and interaction with the other microservices. The microservices architecture propose a new type of relationship between the application and the database. Instead of sharing a single database schema with other services, each service has its own database schema. Having a database schema per service is essential if you want to benefit from microservices, because it ensures loose coupling. Normally, the communication with the client is mediated by an intermediary known as an API Gateway. The API Gateway is responsible for tasks such as load balancing, caching, access control, API metering, and monitoring. Figure 2: Example of application implemented following the microservices architecture. Source: Microservices.io Companies using microservice architecture: Netflix, Amazon, Ebay, Uber, Sound Cloud, etc. Beneficts If one microservice fails, the whole system does not crash Facilitates scalability of the application. Gives developers the freedom to independently develop and deploy services. Different programming languages can be used in different modules. Easy to maintain, modify and reuse. The most recommended technology can be used for each problem. Easy to scale and manage development teams. Disadvantages Testing can be difficult due to distributed deployment. If the design is not done properly, this architecture could lead with latency problems, load balancing, etc. High memory consumption Complexity in integrating and managing a large number of services. The members of a development group must have good background training. Additional resources Microservices (ENG) Microservices Guide by James Lewis and Martin Fowler (ENG) Wikipedia: Microservices (ENG) Workshop Module 1: Introduction to Microservices dotNet (ENG)","title":"Introduction to microservices (ENG)"},{"location":"microservices/#introduction-to-microservices","text":"Typically, the application structure is based on a monolithic architecture scheme. In this architecture, all the elements implemented are included in a single application. The monolithic architecture has some disadvantages, such as it becomes more difficult to solve problems and add new functionalities as the application grows. The microservicies architecture pattern is proposed in order to solve these problems. Figure 1: Microservice vs Monolith architecture. Source: Martin Fowler","title":"Introduction to Microservices"},{"location":"microservices/#what-are-the-microservices","text":"Microservices - also known as the microservice architecture - structures an application as a collection of services. The idea is to split the application into a set of smaller, interconnected services instead of building a single monolithic application. Thus, each microservice is a small application. Ideally, a microservice or service has to be specialized in solving the problems of a single domain using the best available technology. In addition, each service must have an API in order to facilitate communication and interaction with the other microservices. The microservices architecture propose a new type of relationship between the application and the database. Instead of sharing a single database schema with other services, each service has its own database schema. Having a database schema per service is essential if you want to benefit from microservices, because it ensures loose coupling. Normally, the communication with the client is mediated by an intermediary known as an API Gateway. The API Gateway is responsible for tasks such as load balancing, caching, access control, API metering, and monitoring. Figure 2: Example of application implemented following the microservices architecture. Source: Microservices.io Companies using microservice architecture: Netflix, Amazon, Ebay, Uber, Sound Cloud, etc.","title":"What are the microservices?"},{"location":"microservices/#beneficts","text":"If one microservice fails, the whole system does not crash Facilitates scalability of the application. Gives developers the freedom to independently develop and deploy services. Different programming languages can be used in different modules. Easy to maintain, modify and reuse. The most recommended technology can be used for each problem. Easy to scale and manage development teams.","title":"Beneficts"},{"location":"microservices/#disadvantages","text":"Testing can be difficult due to distributed deployment. If the design is not done properly, this architecture could lead with latency problems, load balancing, etc. High memory consumption Complexity in integrating and managing a large number of services. The members of a development group must have good background training.","title":"Disadvantages"},{"location":"microservices/#additional-resources","text":"Microservices (ENG) Microservices Guide by James Lewis and Martin Fowler (ENG) Wikipedia: Microservices (ENG) Workshop Module 1: Introduction to Microservices dotNet (ENG)","title":"Additional resources"},{"location":"microservicios/","text":"Introducci\u00f3n a los Microservicios Normalmente, la estructura de una aplicaci\u00f3n se basa en el esquema de la Arquitectura Monol\u00edtica. En esta arquitectura, todos los elementos implementado se incluyen en una sola aplicaci\u00f3n. La arquitectura monol\u00edtica tiene algunas desventajas; por ejemplo, se vuelve cada vez m\u00e1s complicado resolver problemas y a\u00f1adir nuevas funcionalidades a la aplicaci\u00f3n a medida que \u00e9sta crece. La arquitectura de microservicios se propone como una opci\u00f3n para resolver estos problemas. Imagen 1: Comparativa de la arquitectura de microservicios y la monol\u00edtica. Fuente: Martin Fowler \u00bfQu\u00e9 son los microservicios? Los microservicios, tambi\u00e9n conocido como arquitectura de microservicios , estructura la aplicaci\u00f3n como una colecci\u00f3n de servicios. La idea es dividir la aplicaci\u00f3n en un conjunto de peque\u00f1os e interconectados servicios en lugar de construir una sola aplicaci\u00f3n monol\u00edtica. Con esto, cada servicio constituye una peque\u00f1a aplicaci\u00f3n. Idealmente, un microservicio o servicio tiene que estar especializado en resolver los problemas de un solo dominio utilizando la mejor tecnolog\u00eda disponible. Adem\u00e1s, cada servicio debe tener una API para facilitar la comunicaci\u00f3n e interacci\u00f3n con otros microservicios. La arquitectura de microservicios propone un nuevo tipo de relaci\u00f3n entre la aplicaci\u00f3n y la base de datos. En lugar de compartir una sola estructura de base de datos con otros servicios, cada servicio tiene su propia estructura. Tener una sola base de datos por servicio es esencial si queremos beneficiarnos de las posibilidades que nos brindan los microservicios, ya que asegura tener loose coupling . Normalmente, la comunicaci\u00f3n con el cliente se realiza mediante un intermediario conocido como API Gateway. La API Gateway es responsable de tareas como el balanceo de carga, el almacenamiento en cach\u00e9, control de acceso, API metering y control. Imagen 2: Ejemplo de aplicaci\u00f3n desarrollada siguiendo la arquitectura de microservicios. Fuente: Microservices.io Compa\u00f1\u00edas que usan la arquitectura de microservicios: Netflix, Amazon, Ebay, Uber, Sound Cloud, etc. Ventajas Si un microservicio falla, no falla el sistema completo Facilita la escalabilidad de la aplicaci\u00f3n. Ofrece a los desarrolladores la libertad de desarrollar e implementar servicios de forma independiente. Se pueden usar diferentes lenguajes de programaci\u00f3n en diferentes m\u00f3dulos. F\u00e1cil de mantener, modificar y reutilizar. Se puede utilizar la tecnolog\u00eda m\u00e1s recomendada para cada problema. F\u00e1cil de escalar y administrar equipos de desarrollo. Desventajas El testeo puede verse dificultado debido a la implementaci\u00f3n distribuida. Si el dise\u00f1o no se realiza correctamente, esta arquitectura podr\u00eda generar problemas de latencia, equilibrio de carga, etc. Alto consumo de memoria Complejidad en la integraci\u00f3n y gesti\u00f3n de una gran cantidad de servicios. Los miembros de un grupo de desarrollo deben tener una buena formaci\u00f3n previa. Recursos adicionales Microservices (ENG) Taller: Introducci\u00f3n a los Microservicios - Tutorial en Python - YouTube Alberto Casero - Keep Coding Microservices Guide by James Lewis and Martin Fowler (ENG) Wikipedia: Microservices (ENG) Workshop Module 1: Introduction to Microservices dotNet (ENG)","title":"Introduction to microservices (SPA)"},{"location":"microservicios/#introduccion-a-los-microservicios","text":"Normalmente, la estructura de una aplicaci\u00f3n se basa en el esquema de la Arquitectura Monol\u00edtica. En esta arquitectura, todos los elementos implementado se incluyen en una sola aplicaci\u00f3n. La arquitectura monol\u00edtica tiene algunas desventajas; por ejemplo, se vuelve cada vez m\u00e1s complicado resolver problemas y a\u00f1adir nuevas funcionalidades a la aplicaci\u00f3n a medida que \u00e9sta crece. La arquitectura de microservicios se propone como una opci\u00f3n para resolver estos problemas. Imagen 1: Comparativa de la arquitectura de microservicios y la monol\u00edtica. Fuente: Martin Fowler","title":"Introducci\u00f3n a los Microservicios"},{"location":"microservicios/#que-son-los-microservicios","text":"Los microservicios, tambi\u00e9n conocido como arquitectura de microservicios , estructura la aplicaci\u00f3n como una colecci\u00f3n de servicios. La idea es dividir la aplicaci\u00f3n en un conjunto de peque\u00f1os e interconectados servicios en lugar de construir una sola aplicaci\u00f3n monol\u00edtica. Con esto, cada servicio constituye una peque\u00f1a aplicaci\u00f3n. Idealmente, un microservicio o servicio tiene que estar especializado en resolver los problemas de un solo dominio utilizando la mejor tecnolog\u00eda disponible. Adem\u00e1s, cada servicio debe tener una API para facilitar la comunicaci\u00f3n e interacci\u00f3n con otros microservicios. La arquitectura de microservicios propone un nuevo tipo de relaci\u00f3n entre la aplicaci\u00f3n y la base de datos. En lugar de compartir una sola estructura de base de datos con otros servicios, cada servicio tiene su propia estructura. Tener una sola base de datos por servicio es esencial si queremos beneficiarnos de las posibilidades que nos brindan los microservicios, ya que asegura tener loose coupling . Normalmente, la comunicaci\u00f3n con el cliente se realiza mediante un intermediario conocido como API Gateway. La API Gateway es responsable de tareas como el balanceo de carga, el almacenamiento en cach\u00e9, control de acceso, API metering y control. Imagen 2: Ejemplo de aplicaci\u00f3n desarrollada siguiendo la arquitectura de microservicios. Fuente: Microservices.io Compa\u00f1\u00edas que usan la arquitectura de microservicios: Netflix, Amazon, Ebay, Uber, Sound Cloud, etc.","title":"\u00bfQu\u00e9 son los microservicios?"},{"location":"microservicios/#ventajas","text":"Si un microservicio falla, no falla el sistema completo Facilita la escalabilidad de la aplicaci\u00f3n. Ofrece a los desarrolladores la libertad de desarrollar e implementar servicios de forma independiente. Se pueden usar diferentes lenguajes de programaci\u00f3n en diferentes m\u00f3dulos. F\u00e1cil de mantener, modificar y reutilizar. Se puede utilizar la tecnolog\u00eda m\u00e1s recomendada para cada problema. F\u00e1cil de escalar y administrar equipos de desarrollo.","title":"Ventajas"},{"location":"microservicios/#desventajas","text":"El testeo puede verse dificultado debido a la implementaci\u00f3n distribuida. Si el dise\u00f1o no se realiza correctamente, esta arquitectura podr\u00eda generar problemas de latencia, equilibrio de carga, etc. Alto consumo de memoria Complejidad en la integraci\u00f3n y gesti\u00f3n de una gran cantidad de servicios. Los miembros de un grupo de desarrollo deben tener una buena formaci\u00f3n previa.","title":"Desventajas"},{"location":"microservicios/#recursos-adicionales","text":"Microservices (ENG) Taller: Introducci\u00f3n a los Microservicios - Tutorial en Python - YouTube Alberto Casero - Keep Coding Microservices Guide by James Lewis and Martin Fowler (ENG) Wikipedia: Microservices (ENG) Workshop Module 1: Introduction to Microservices dotNet (ENG)","title":"Recursos adicionales"},{"location":"ms_class/","text":"Microservices class The Microservice class is the core of all microservices built with PyMS. You can create a simple microservice such as: from flask import jsonify from pyms.flask.app import Microservice ms = Microservice(path=__file__) app = ms.create_app() @app.route(\"/\") def example(): return jsonify({\"main\": \"hello world\"}) if __name__ == '__main__': app.run() And a config file like this config.yml pyms: config: APP_NAME: \"Python Microservice\" Check the Configuration section to learn how to create a configuration file. The Microservice class searches for a config.yml in the directory you pass in path parameter or looks for the file in PYMS_CONFIGMAP_FILE env var. Each keyword in our configuration block, can be accessed in our Microservice object through the attribute config . # Config.yml pyms: config: app_name: \"Python Microservice\" foo: \"var\" multiplevars: config1: \"test1\" config2: \"test2\" #app.py from pyms.flask.app import Microservice ms = Microservice(path=__file__) print(ms.config.APP_NAME) # >> \"Python Microservice\" print(ms.config.app_name) # >> \"Python Microservice\" print(ms.config.foo) # >> \"bar\" print(ms.config.multiplevars.config1) # >> \"test1\" print(ms.config.multiplevars.config2) # >> \"test2\" Personalize your microservices The Microservice class initializes libraries and other process in the following way: ... def create_app(self): \"\"\"Initialize the Flask app, register blueprints and initialize all libraries like Swagger, database, the trace system... return the app and the database objects. :return: \"\"\" self.application = self.init_app() self.application.config.from_object(self.config) self.application.tracer = None self.application.ms = self # Initialize Blueprints self.application.register_blueprint(healthcheck_blueprint) self.init_libs() self.add_error_handlers() self.init_tracer() self.init_logger() return self.application Check for more examples in this Github page","title":"Microservice class"},{"location":"ms_class/#microservices-class","text":"The Microservice class is the core of all microservices built with PyMS. You can create a simple microservice such as: from flask import jsonify from pyms.flask.app import Microservice ms = Microservice(path=__file__) app = ms.create_app() @app.route(\"/\") def example(): return jsonify({\"main\": \"hello world\"}) if __name__ == '__main__': app.run() And a config file like this config.yml pyms: config: APP_NAME: \"Python Microservice\" Check the Configuration section to learn how to create a configuration file. The Microservice class searches for a config.yml in the directory you pass in path parameter or looks for the file in PYMS_CONFIGMAP_FILE env var. Each keyword in our configuration block, can be accessed in our Microservice object through the attribute config . # Config.yml pyms: config: app_name: \"Python Microservice\" foo: \"var\" multiplevars: config1: \"test1\" config2: \"test2\" #app.py from pyms.flask.app import Microservice ms = Microservice(path=__file__) print(ms.config.APP_NAME) # >> \"Python Microservice\" print(ms.config.app_name) # >> \"Python Microservice\" print(ms.config.foo) # >> \"bar\" print(ms.config.multiplevars.config1) # >> \"test1\" print(ms.config.multiplevars.config2) # >> \"test2\"","title":"Microservices class"},{"location":"ms_class/#personalize-your-microservices","text":"The Microservice class initializes libraries and other process in the following way: ... def create_app(self): \"\"\"Initialize the Flask app, register blueprints and initialize all libraries like Swagger, database, the trace system... return the app and the database objects. :return: \"\"\" self.application = self.init_app() self.application.config.from_object(self.config) self.application.tracer = None self.application.ms = self # Initialize Blueprints self.application.register_blueprint(healthcheck_blueprint) self.init_libs() self.add_error_handlers() self.init_tracer() self.init_logger() return self.application Check for more examples in this Github page","title":"Personalize your microservices"},{"location":"quickstart/","text":"Quickstart This page gives a good introduction to PyMS. It assumes you already have PyMS installed. If you do not, head over to the Installation section. To start out, you need to create 2 files: main.py and config.yml: main.py from flask import jsonify from pyms.flask.app import Microservice ms = Microservice() # 1.1 app = ms.create_app() # 2.1 @app.route(\"/\") # 3.1 def example(): return jsonify({\"main\": \"hello world\"}) if __name__ == '__main__': app.run() config.yml pyms: services: # 1.2 requests: data: {} config: # 1.3 DEBUG: true APP_NAME: business-glossary APPLICATION_ROOT : \"\" SECRET_KEY: \"gjr39dkjn344_!67#\" So what did that code do? Create a instance of PyMS Microservice class (#1.1). This initialization injects the configuration defined in the 1.3 block, so it could be accessed through current_app.config. Then, it initializes the service defined in the 1.2 block. See Services for more details. Initialize Flask instance, Connexion if it was defined in the pyms configuration block, create a tracer, add health-check blueprint, initialize libs and set the PyMS Microservice in ms attribute and you can access to it with current_app.ms . These steps all have their own functions and you can easy override any of them. create_app returns the flask instance and you can interact with it as a typical flask app Create a project from scaffold PyMS has a command line option to create a project template like Microservices Scaffold . This command uses cookiecutter to download and install this template Warning First, you must run pip install cookiecutter==1.7.0 Installation pyms startproject this outputs a lot of options step by step project_repo_url [https://github.com/python-microservices/microservices-scaffold]: project_name [Python Microservices Boilerplate]: example project project_folder [example_project]: project_short_description [Python Boilerplate contains all the boilerplate you need to create a Python package.]: create_model_class [y]: microservice_with_swagger_and_connexion [y]: microservice_with_traces [y]: microservice_with_metrics [y]: application_root [/example_project]: Select open_source_license: 1 - MIT license 2 - BSD license 3 - ISC license 4 - Apache Software License 2.0 5 - GNU General Public License v3 6 - Not open source Choose from 1, 2, 3, 4, 5, 6 [1]: When you finish introducing the options, a project will be created in [project_folder] folder What's next? See Configuration , Routing and Examples to continue with this tutorial","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"This page gives a good introduction to PyMS. It assumes you already have PyMS installed. If you do not, head over to the Installation section. To start out, you need to create 2 files: main.py and config.yml: main.py from flask import jsonify from pyms.flask.app import Microservice ms = Microservice() # 1.1 app = ms.create_app() # 2.1 @app.route(\"/\") # 3.1 def example(): return jsonify({\"main\": \"hello world\"}) if __name__ == '__main__': app.run() config.yml pyms: services: # 1.2 requests: data: {} config: # 1.3 DEBUG: true APP_NAME: business-glossary APPLICATION_ROOT : \"\" SECRET_KEY: \"gjr39dkjn344_!67#\"","title":"Quickstart"},{"location":"quickstart/#so-what-did-that-code-do","text":"Create a instance of PyMS Microservice class (#1.1). This initialization injects the configuration defined in the 1.3 block, so it could be accessed through current_app.config. Then, it initializes the service defined in the 1.2 block. See Services for more details. Initialize Flask instance, Connexion if it was defined in the pyms configuration block, create a tracer, add health-check blueprint, initialize libs and set the PyMS Microservice in ms attribute and you can access to it with current_app.ms . These steps all have their own functions and you can easy override any of them. create_app returns the flask instance and you can interact with it as a typical flask app","title":"So what did that code do?"},{"location":"quickstart/#create-a-project-from-scaffold","text":"PyMS has a command line option to create a project template like Microservices Scaffold . This command uses cookiecutter to download and install this template Warning First, you must run pip install cookiecutter==1.7.0","title":"Create a project from scaffold"},{"location":"quickstart/#installation","text":"pyms startproject this outputs a lot of options step by step project_repo_url [https://github.com/python-microservices/microservices-scaffold]: project_name [Python Microservices Boilerplate]: example project project_folder [example_project]: project_short_description [Python Boilerplate contains all the boilerplate you need to create a Python package.]: create_model_class [y]: microservice_with_swagger_and_connexion [y]: microservice_with_traces [y]: microservice_with_metrics [y]: application_root [/example_project]: Select open_source_license: 1 - MIT license 2 - BSD license 3 - ISC license 4 - Apache Software License 2.0 5 - GNU General Public License v3 6 - Not open source Choose from 1, 2, 3, 4, 5, 6 [1]: When you finish introducing the options, a project will be created in [project_folder] folder","title":"Installation"},{"location":"quickstart/#whats-next","text":"See Configuration , Routing and Examples to continue with this tutorial","title":"What's next?"},{"location":"contributing/","text":"Contributing Branch workflow Warning READ BEFORE CREATE A BRANCH OR OPEN A PR/MR We use Github Glow Commit Message Guidelines The messages of the commits use Conventional Commits See Angular guideline Installation After cloning this repo, create a virtualenv and ensure dependencies are installed by running: virtualenv venv source venv/bin/activate pip install -e \".[test]\" Pipenv Advantages over plain pip and requirements.txt Pipenv generates two files: a Pipfile and a Pipfile.lock . * Pipfile : Is a high level declaration of the dependencies of your project. It can contain \"dev\" dependencies (usually test related stuff) and \"standard\" dependencies which are the ones you'll need for your project to function * Pipfile.lock : Is the \"list\" of all the dependencies your Pipfile has installed, along with their version and their hashes. This prevents two things: Conflicts between dependencies and installing a malicious module. How to... Here the most 'common' pipenv commands, for a more in-depth explanation please refer to the official documentation . Install pipenv pip install pipenv Install dependencies defined in a Pipfile pipenv install Install both dev and \"standard\" dependencies defined in a Pipfile pipenv install --dev Install a new module pipenv install django Install a new dev module (usually test related stuff) pipenv install nose --dev Install dependencies in production pipenv install --deploy Start a shell pipenv shell Testing Well-written tests and maintaining good test coverage is important to this project. While developing, run new and existing tests with: pytest --cov=[project/pyms/...] --cov=tests tests/ Add the -s flag if you have introduced breakpoints into the code for debugging. Add the -v (\"verbose\") flag to get more detailed test output. For even more detailed output, use -vv . Check out the pytest documentation for more options and test running controls. PyMS supports several versions of Python3. To make sure that changes do not break compatibility with any of those versions, we use tox to create virtualenvs for each Python version and run tests with that version. To run against all Python versions defined in the tox.ini config file, just run: tox If you wish to run against a specific version defined in the tox.ini file: tox -e py36 Tox can only use whatever versions of Python are installed on your system. When you create a pull request, Travis will also be running the same tests and report the results, so there is no need for potential contributors to try to install every single version of Python on their own system ahead of time. Linters MyPy mypy [project/pyms/...] Flake8 flake8 [project/pyms/...] --show-source --statistics --statistics Pylint pylint --rcfile=pylintrc [project/pyms/...] Tutorial: Create your own service See this tutorial","title":"Index"},{"location":"contributing/#contributing","text":"","title":"Contributing"},{"location":"contributing/#branch-workflow","text":"Warning READ BEFORE CREATE A BRANCH OR OPEN A PR/MR We use Github Glow","title":"Branch workflow"},{"location":"contributing/#commit-message-guidelines","text":"The messages of the commits use Conventional Commits See Angular guideline","title":"Commit Message Guidelines"},{"location":"contributing/#installation","text":"After cloning this repo, create a virtualenv and ensure dependencies are installed by running: virtualenv venv source venv/bin/activate pip install -e \".[test]\"","title":"Installation"},{"location":"contributing/#pipenv","text":"","title":"Pipenv"},{"location":"contributing/#advantages-over-plain-pip-and-requirementstxt","text":"Pipenv generates two files: a Pipfile and a Pipfile.lock . * Pipfile : Is a high level declaration of the dependencies of your project. It can contain \"dev\" dependencies (usually test related stuff) and \"standard\" dependencies which are the ones you'll need for your project to function * Pipfile.lock : Is the \"list\" of all the dependencies your Pipfile has installed, along with their version and their hashes. This prevents two things: Conflicts between dependencies and installing a malicious module.","title":"Advantages over plain pip and requirements.txt"},{"location":"contributing/#how-to","text":"Here the most 'common' pipenv commands, for a more in-depth explanation please refer to the official documentation .","title":"How to..."},{"location":"contributing/#install-pipenv","text":"pip install pipenv","title":"Install pipenv"},{"location":"contributing/#install-dependencies-defined-in-a-pipfile","text":"pipenv install","title":"Install dependencies defined in a Pipfile"},{"location":"contributing/#install-both-dev-and-standard-dependencies-defined-in-a-pipfile","text":"pipenv install --dev","title":"Install both dev and \"standard\" dependencies defined in a Pipfile"},{"location":"contributing/#install-a-new-module","text":"pipenv install django","title":"Install a new module"},{"location":"contributing/#install-a-new-dev-module-usually-test-related-stuff","text":"pipenv install nose --dev","title":"Install a new dev module (usually test related stuff)"},{"location":"contributing/#install-dependencies-in-production","text":"pipenv install --deploy","title":"Install dependencies in production"},{"location":"contributing/#start-a-shell","text":"pipenv shell","title":"Start a shell"},{"location":"contributing/#testing","text":"Well-written tests and maintaining good test coverage is important to this project. While developing, run new and existing tests with: pytest --cov=[project/pyms/...] --cov=tests tests/ Add the -s flag if you have introduced breakpoints into the code for debugging. Add the -v (\"verbose\") flag to get more detailed test output. For even more detailed output, use -vv . Check out the pytest documentation for more options and test running controls. PyMS supports several versions of Python3. To make sure that changes do not break compatibility with any of those versions, we use tox to create virtualenvs for each Python version and run tests with that version. To run against all Python versions defined in the tox.ini config file, just run: tox If you wish to run against a specific version defined in the tox.ini file: tox -e py36 Tox can only use whatever versions of Python are installed on your system. When you create a pull request, Travis will also be running the same tests and report the results, so there is no need for potential contributors to try to install every single version of Python on their own system ahead of time.","title":"Testing"},{"location":"contributing/#linters","text":"","title":"Linters"},{"location":"contributing/#mypy","text":"mypy [project/pyms/...]","title":"MyPy"},{"location":"contributing/#flake8","text":"flake8 [project/pyms/...] --show-source --statistics --statistics","title":"Flake8"},{"location":"contributing/#pylint","text":"pylint --rcfile=pylintrc [project/pyms/...]","title":"Pylint"},{"location":"contributing/#tutorial-create-your-own-service","text":"See this tutorial","title":"Tutorial: Create your own service"},{"location":"contributing/structure/","text":"Structure pyms/config Module to read yaml or json configuration from a dictionary or a path. pyms/flask/app With the function create_app we initialize the Flask app, register blueprints and initialize all other libraries such as Swagger, database, trace system, custom logger format, etc. pyms/flask/services Integrations and wrappers over common libs like request, swagger, connexion or metrics. pyms/flask/healthcheck This view is usually used by Kubernetes, Eureka and other systems to check if our application is running. pyms/logger Print logger in JSON format to send to server like Elasticsearch. Inject span traces in logger.","title":"PyMS structure"},{"location":"contributing/structure/#structure","text":"","title":"Structure"},{"location":"contributing/structure/#pymsconfig","text":"Module to read yaml or json configuration from a dictionary or a path.","title":"pyms/config"},{"location":"contributing/structure/#pymsflaskapp","text":"With the function create_app we initialize the Flask app, register blueprints and initialize all other libraries such as Swagger, database, trace system, custom logger format, etc.","title":"pyms/flask/app"},{"location":"contributing/structure/#pymsflaskservices","text":"Integrations and wrappers over common libs like request, swagger, connexion or metrics.","title":"pyms/flask/services"},{"location":"contributing/structure/#pymsflaskhealthcheck","text":"This view is usually used by Kubernetes, Eureka and other systems to check if our application is running.","title":"pyms/flask/healthcheck"},{"location":"contributing/structure/#pymslogger","text":"Print logger in JSON format to send to server like Elasticsearch. Inject span traces in logger.","title":"pyms/logger"},{"location":"scaffold/","text":"Python Microservices Python Microservice Scaffold is an example of how to structure a Flask Microservice Project. This Scaffold is build over PyMS package. PyMS is a Microservice chassis pattern like Spring Boot (Java) or Gizmo (Golang). PyMS is a collection of libraries, best practices and recommended ways to build microservices with Python which handles cross-cutting concerns: Externalized configuration Logging Health checks Metrics Distributed tracing Stack PyMS Flask connexion Opentracing SQLAlchemy Flask-SQLAlchemy Flask-Script","title":"Index"},{"location":"scaffold/#python-microservices","text":"Python Microservice Scaffold is an example of how to structure a Flask Microservice Project. This Scaffold is build over PyMS package. PyMS is a Microservice chassis pattern like Spring Boot (Java) or Gizmo (Golang). PyMS is a collection of libraries, best practices and recommended ways to build microservices with Python which handles cross-cutting concerns: Externalized configuration Logging Health checks Metrics Distributed tracing","title":"Python Microservices"},{"location":"scaffold/#stack","text":"PyMS Flask connexion Opentracing SQLAlchemy Flask-SQLAlchemy Flask-Script","title":"Stack"},{"location":"scaffold/configuration/","text":"Configuration Project configuration is loaded using PyMS package based on yml or json file. Some example files are config.yml, config-docker.yml and tests/config-tests.yml or see PyMS configuration Documentation The Microservice create a URL to inspect the Swagger documentation of the api in: localhost:5000/[APPLICATION_ROOT]/ui/ This URL is set in your config.yml : pyms: config: DEBUG: false TESTING: false APP_NAME: Template APPLICATION_ROOT : \"\" <--- Our API Rest work with connexion . You can see connexion docs or the official Swagger documentation to add the syntax to your APIS and create your Swagger docs","title":"Configuration"},{"location":"scaffold/configuration/#configuration","text":"Project configuration is loaded using PyMS package based on yml or json file. Some example files are config.yml, config-docker.yml and tests/config-tests.yml or see PyMS configuration","title":"Configuration"},{"location":"scaffold/configuration/#documentation","text":"The Microservice create a URL to inspect the Swagger documentation of the api in: localhost:5000/[APPLICATION_ROOT]/ui/ This URL is set in your config.yml : pyms: config: DEBUG: false TESTING: false APP_NAME: Template APPLICATION_ROOT : \"\" <--- Our API Rest work with connexion . You can see connexion docs or the official Swagger documentation to add the syntax to your APIS and create your Swagger docs","title":"Documentation"},{"location":"scaffold/installation/","text":"Installation Clone the project git clone https://github.com/python-microservices/microservices-scaffold.git Install your virtualenv virtualenv --python=python[3.6|3.7|3.8] venv source venv/bin/activate pip install -r requirements.txt Or install with pipenv pip install pipenv pipenv install Advantages over plain pip and requirements.txt Pipenv generates two files: a Pipfile and a Pipfile.lock . Pipfile : Is a high level declaration of the dependencies of your project. It can contain \"dev\" dependencies (usually test related stuff) and \"standard\" dependencies which are the ones you'll need for your project to function Pipfile.lock : Is the \"list\" of all the dependencies your Pipfile has installed, along with their version and their hashes. This prevents two things: Conflicts between dependencies and installing a malicious module. Configure your project and the path of your MS. See configuration section. Configure your setup.py with your project information","title":"Installation"},{"location":"scaffold/installation/#installation","text":"Clone the project git clone https://github.com/python-microservices/microservices-scaffold.git Install your virtualenv virtualenv --python=python[3.6|3.7|3.8] venv source venv/bin/activate pip install -r requirements.txt Or install with pipenv pip install pipenv pipenv install","title":"Installation"},{"location":"scaffold/installation/#advantages-over-plain-pip-and-requirementstxt","text":"Pipenv generates two files: a Pipfile and a Pipfile.lock . Pipfile : Is a high level declaration of the dependencies of your project. It can contain \"dev\" dependencies (usually test related stuff) and \"standard\" dependencies which are the ones you'll need for your project to function Pipfile.lock : Is the \"list\" of all the dependencies your Pipfile has installed, along with their version and their hashes. This prevents two things: Conflicts between dependencies and installing a malicious module. Configure your project and the path of your MS. See configuration section. Configure your setup.py with your project information","title":"Advantages over plain pip and requirements.txt"},{"location":"scaffold/quickstart/","text":"Installation Clone the repository git clone git@github.com:purwowd/microservices-scaffold.git cd microservices-scaffold Install with virtualenv virtualenv --python=python[3.6|3.7|3.8] venv source venv/bin/activate pip install -r requirements.txt Install with pipenv pip install pipenv pipenv install Install on MacOS virtualenv -p python3 venv source venv/bin/activate pip3 install -r requirements.txt python manage.py runserver Advantages over plain pip and requirements.txt Pipenv generates two files: a Pipfile and a Pipfile.lock . * Pipfile : Is a high level declaration of the dependencies of your project. It can contain \"dev\" dependencies (usually test related stuff) and \"standard\" dependencies which are the ones you'll need for your project to function * Pipfile.lock : Is the \"list\" of all the dependencies your Pipfile has installed, along with their version and their hashes. This prevents two things: Conflicts between dependencies and installing a malicious module. For a more in-depth explanation please refer to the official documentation . Run your python script python manage.py runserver Check the result Your default endpoints will be in this url: http://127.0.0.1:5000/films http://127.0.0.1:5000/actors This URL is set in your config.yml : pyms: config: DEBUG: false TESTING: false APP_NAME: Template APPLICATION_ROOT : \"\" # <!--- You can acceded to a swagger ui in the next url: http://127.0.0.1:5000/ui/ This PATH is set in your config.yml : pyms: services: swagger: path: \"swagger\" file: \"swagger.yaml\" url: \"/ui/\" # <!--- Template You can create your own project from template: github.com/python-microservices/microservices-template","title":"Quickstart"},{"location":"scaffold/quickstart/#installation","text":"","title":"Installation"},{"location":"scaffold/quickstart/#clone-the-repository","text":"git clone git@github.com:purwowd/microservices-scaffold.git cd microservices-scaffold","title":"Clone the repository"},{"location":"scaffold/quickstart/#install-with-virtualenv","text":"virtualenv --python=python[3.6|3.7|3.8] venv source venv/bin/activate pip install -r requirements.txt","title":"Install with virtualenv"},{"location":"scaffold/quickstart/#install-with-pipenv","text":"pip install pipenv pipenv install","title":"Install with pipenv"},{"location":"scaffold/quickstart/#install-on-macos","text":"virtualenv -p python3 venv source venv/bin/activate pip3 install -r requirements.txt python manage.py runserver","title":"Install on MacOS"},{"location":"scaffold/quickstart/#advantages-over-plain-pip-and-requirementstxt","text":"Pipenv generates two files: a Pipfile and a Pipfile.lock . * Pipfile : Is a high level declaration of the dependencies of your project. It can contain \"dev\" dependencies (usually test related stuff) and \"standard\" dependencies which are the ones you'll need for your project to function * Pipfile.lock : Is the \"list\" of all the dependencies your Pipfile has installed, along with their version and their hashes. This prevents two things: Conflicts between dependencies and installing a malicious module. For a more in-depth explanation please refer to the official documentation .","title":"Advantages over plain pip and requirements.txt"},{"location":"scaffold/quickstart/#run-your-python-script","text":"python manage.py runserver","title":"Run your python script"},{"location":"scaffold/quickstart/#check-the-result","text":"Your default endpoints will be in this url: http://127.0.0.1:5000/films http://127.0.0.1:5000/actors This URL is set in your config.yml : pyms: config: DEBUG: false TESTING: false APP_NAME: Template APPLICATION_ROOT : \"\" # <!--- You can acceded to a swagger ui in the next url: http://127.0.0.1:5000/ui/ This PATH is set in your config.yml : pyms: services: swagger: path: \"swagger\" file: \"swagger.yaml\" url: \"/ui/\" # <!---","title":"Check the result"},{"location":"scaffold/quickstart/#template","text":"You can create your own project from template: github.com/python-microservices/microservices-template","title":"Template"},{"location":"scaffold/runindocker/","text":"Docker You can dockerize this microservice with these steps: * Create and push the image docker build -t films -f Dockerfile . Run the image: docker run -d -p 5000:5000 films","title":"Run in Docker"},{"location":"scaffold/runindocker/#docker","text":"You can dockerize this microservice with these steps: * Create and push the image docker build -t films -f Dockerfile . Run the image: docker run -d -p 5000:5000 films","title":"Docker"},{"location":"scaffold/runinkubernetes/","text":"Run in kubernetes Use MS with Docker Install docker Use MS with Kubernetes locally We create a extensive example an tutorial about use Python microservice scaffold with Kubernetes in this repository: https://github.com/python-microservices/microservices-chat In the next lines, you can find a simple tutorial tu run this microservice in a simple Kubernetes cluster Installing Kubernetes... curl -Lo kubectl https://storage.googleapis.com/kubernetes-release/release/v1.9.0/bin/linux/amd64/kubectl && chmod +x kubectl && sudo mv kubectl /usr/local/bin/ Installing Minikube... curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 && chmod +x minikube && sudo mv minikube /usr/local/bin/ Start minikube and set the environment of docker minikube start eval $(minikube docker-env) kubectl config use-context minikube If a shell isn't your friend. You could use kubernetes web panel to see your pods: minikube dashboard Create your image docker build -t template:v1 . Deploy your images locally: kubectl apply -f service.yaml minikube service template Clean your environment kubectl delete template kubectl delete template docker rmi template:v1 -f minikube stop eval $(minikube docker-env -u) minikube delete","title":"Run in Kubernetes"},{"location":"scaffold/runinkubernetes/#run-in-kubernetes","text":"","title":"Run in kubernetes"},{"location":"scaffold/runinkubernetes/#use-ms-with-docker","text":"Install docker","title":"Use MS with Docker"},{"location":"scaffold/runinkubernetes/#use-ms-with-kubernetes-locally","text":"We create a extensive example an tutorial about use Python microservice scaffold with Kubernetes in this repository: https://github.com/python-microservices/microservices-chat In the next lines, you can find a simple tutorial tu run this microservice in a simple Kubernetes cluster Installing Kubernetes... curl -Lo kubectl https://storage.googleapis.com/kubernetes-release/release/v1.9.0/bin/linux/amd64/kubectl && chmod +x kubectl && sudo mv kubectl /usr/local/bin/ Installing Minikube... curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 && chmod +x minikube && sudo mv minikube /usr/local/bin/ Start minikube and set the environment of docker minikube start eval $(minikube docker-env) kubectl config use-context minikube If a shell isn't your friend. You could use kubernetes web panel to see your pods: minikube dashboard Create your image docker build -t template:v1 . Deploy your images locally: kubectl apply -f service.yaml minikube service template Clean your environment kubectl delete template kubectl delete template docker rmi template:v1 -f minikube stop eval $(minikube docker-env -u) minikube delete","title":"Use MS with Kubernetes locally"},{"location":"services/routing/","text":"Routing With PyMS you can extend the Microservice with Connexion and swagger-ui . To use connexion, you must set in your config.yaml this: pyms: services: [...] swagger: path: \"\" file: \"swagger.yaml\" config: [...] If you want to know more about configure swagger service, see Service section . Now, you can create a swagger.yaml file with OpenAPI Specification . Examples of routing You can see how to structure a project or OpenAPI Specification in PyMS examples or in Microservice Scaffold Routing to files This section is equal to Zalando Connexion , because PyMS uses this library to route endpoints to functions: Explicit Routing : paths: /hello_world: post: operationId: myapp.api.hello_world If you provide this path in your specification POST requests to http://MYHOST/hello_world , it will be handled by the function hello_world in the myapp.api module. Optionally, you can include x-swagger-router-controller (or x-openapi-router-controller ) in your operation definition, making operationId relative: paths: /hello_world: post: x-swagger-router-controller: myapp.api operationId: hello_world Keep in mind that Connexion follows how HTTP methods work in Flask _ and therefore HEAD requests will be handled by the operationId specified under GET in the specification. If both methods are supported, connexion.request.method can be used to determine which request was made. Automatic Routing To customize this behavior, Connexion can use alternative Resolvers --for example, RestyResolver . The RestyResolver will compose an operationId based on the path and HTTP method of the endpoints in your specification: from pyms.flask.app import Microservice ms = Microservice(path=__file__) paths: /: get: # Implied operationId: api.get /foo: get: # Implied operationId: api.foo.search post: # Implied operationId: api.foo.post '/foo/{id}': get: # Implied operationId: api.foo.get put: # Implied operationId: api.foo.put copy: # Implied operationId: api.foo.copy delete: # Implied operationId: api.foo.delete RestyResolver will give precedence to any operationId encountered in the specification. It will also respect x-router-controller . You can import and extend connexion.resolver.Resolver to implement your own operationId (and function) resolution algorithm. Automatic Parameter Handling Connexion automatically maps the parameters defined in your endpoint specification to arguments of your Python views as named parameters, and, whenever possible, with value casting. Simply define the endpoint's parameters with the same names as your views arguments. As an example, say you have an endpoint specified as: paths: /foo: get: operationId: api.foo_get parameters: - name: message description: Some message. in: query type: string required: true And the view function: # api.py file def foo_get(message): # do something return 'You send the message: {}'.format(message), 200 In this example, Connexion automatically recognizes that your view function expects an argument named message and assigns the value of the endpoint parameter message to your view function.","title":"Routing"},{"location":"services/routing/#routing","text":"With PyMS you can extend the Microservice with Connexion and swagger-ui . To use connexion, you must set in your config.yaml this: pyms: services: [...] swagger: path: \"\" file: \"swagger.yaml\" config: [...] If you want to know more about configure swagger service, see Service section . Now, you can create a swagger.yaml file with OpenAPI Specification .","title":"Routing"},{"location":"services/routing/#examples-of-routing","text":"You can see how to structure a project or OpenAPI Specification in PyMS examples or in Microservice Scaffold","title":"Examples of routing"},{"location":"services/routing/#routing-to-files","text":"This section is equal to Zalando Connexion , because PyMS uses this library to route endpoints to functions: Explicit Routing : paths: /hello_world: post: operationId: myapp.api.hello_world If you provide this path in your specification POST requests to http://MYHOST/hello_world , it will be handled by the function hello_world in the myapp.api module. Optionally, you can include x-swagger-router-controller (or x-openapi-router-controller ) in your operation definition, making operationId relative: paths: /hello_world: post: x-swagger-router-controller: myapp.api operationId: hello_world Keep in mind that Connexion follows how HTTP methods work in Flask _ and therefore HEAD requests will be handled by the operationId specified under GET in the specification. If both methods are supported, connexion.request.method can be used to determine which request was made.","title":"Routing to files"},{"location":"services/routing/#automatic-routing","text":"To customize this behavior, Connexion can use alternative Resolvers --for example, RestyResolver . The RestyResolver will compose an operationId based on the path and HTTP method of the endpoints in your specification: from pyms.flask.app import Microservice ms = Microservice(path=__file__) paths: /: get: # Implied operationId: api.get /foo: get: # Implied operationId: api.foo.search post: # Implied operationId: api.foo.post '/foo/{id}': get: # Implied operationId: api.foo.get put: # Implied operationId: api.foo.put copy: # Implied operationId: api.foo.copy delete: # Implied operationId: api.foo.delete RestyResolver will give precedence to any operationId encountered in the specification. It will also respect x-router-controller . You can import and extend connexion.resolver.Resolver to implement your own operationId (and function) resolution algorithm.","title":"Automatic Routing"},{"location":"services/routing/#automatic-parameter-handling","text":"Connexion automatically maps the parameters defined in your endpoint specification to arguments of your Python views as named parameters, and, whenever possible, with value casting. Simply define the endpoint's parameters with the same names as your views arguments. As an example, say you have an endpoint specified as: paths: /foo: get: operationId: api.foo_get parameters: - name: message description: Some message. in: query type: string required: true And the view function: # api.py file def foo_get(message): # do something return 'You send the message: {}'.format(message), 200 In this example, Connexion automatically recognizes that your view function expects an argument named message and assigns the value of the endpoint parameter message to your view function.","title":"Automatic Parameter Handling"},{"location":"services/services/","text":"Services Services are libraries, resources and extensions added to the Microservice in the configuration file. These services are created as an attribute of the Microservice class to use in the code. To add a service check the configuration section . You can declare a service but activate/deactivate with the keyword enabled , like so: pyms: services: requests: enabled: false Currently availabe services are: Swagger / connexion Extends the Microservice with Connexion and swagger-ui . Installation You must install pyms with pip install py-ms[all] or pip install py-ms[swagger] Configuration The parameters you can add to your config are the following: path: The relative or absolute route to your swagger yaml file. The default value is the current directory file: The name of you swagger yaml file. The default value is swagger.yaml url: The url where swagger run in your server. The default value is /ui/ . project_dir: Relative path of the project folder to automatic routing, See this link for more info . The default value is project . See Routing in this documentation to how configure your Swagger. Example pyms: services: swagger: path: \"swagger\" file: \"swagger.yaml\" url: \"/ui/\" project_dir: \"project.views\" Requests Extend the requests library with trace headers and parsing JSON objects. Encapsulates common rest operations between business services propagating trace headers if set up. Installation You must install pyms with pip install py-ms[all] or pip install py-ms[request] Configuration The parameters you can add to your config are: data: wrap the response in a data field of an envelope object, and add other meta data to that wrapper. The default value is None retries: If the response is not correct, this specifies the amount of times it performs the request again. The default number of retries is 3. status_retries: List of response status codes that are considered \"not correct\". The default values are [500, 502, 504] propagate_headers: Propagate the headers of the current execution to the request. The default values is False Example pyms: services: requests: data: \"data\" retries: 4 status_retries: [400, 401, 402, 403, 404, 405, 500, 501, 502, 503] propagate_headers: true Tracer Add traces to all executions with opentracing . This service solves the problem of distributed tracing See Propagate traces tutorial in this documentation for more information. Installation You must install pyms with pip install pyms[all] or pip install pyms[trace] Configuration The parameters you can add to your config are: client: set the client that will receive the traces, The current options are Jaeger and Lightstep . The default value is jaeger. host: The url to send the data of traces. Check this tutorial to create your own server component_name: The name of your application to show in Prometheus metrics Example pyms: services: tracer: client: \"jaeger\" host: \"localhost\" component_name: \"Python Microservice\" Metrics Adds Prometheus metrics using the Prometheus Client Library . The following metrics are currently available: Incoming requests latency as a histogram Incoming requests number as a counter, divided by HTTP method, endpoint and HTTP status Total number of log events divided by level If tracer service activated and it's jaeger, it will show its metrics Installation You must install pyms with pip install py-ms[all] or pip install py-ms[metrics] Example pyms: services: metrics: true This will add the endpoint /metrics to your microservice, which will expose the metrics. Service discovery Adds Consul as service discovery using the Consul Client Library or create your own service discovery See Service Ddiscovery section in this documentation for more information. Installation You must install pyms with pip install py-ms[all] or pip install py-ms[consul] Example pyms: services: service_discovery: service: consul host: localhost port: 8500 autoregister: true This will add the endpoint /metrics to your microservice, which will expose the metrics. How to contrib: See tutorial","title":"List of services"},{"location":"services/services/#services","text":"Services are libraries, resources and extensions added to the Microservice in the configuration file. These services are created as an attribute of the Microservice class to use in the code. To add a service check the configuration section . You can declare a service but activate/deactivate with the keyword enabled , like so: pyms: services: requests: enabled: false Currently availabe services are:","title":"Services"},{"location":"services/services/#swagger-connexion","text":"Extends the Microservice with Connexion and swagger-ui .","title":"Swagger / connexion"},{"location":"services/services/#installation","text":"You must install pyms with pip install py-ms[all] or pip install py-ms[swagger]","title":"Installation"},{"location":"services/services/#configuration","text":"The parameters you can add to your config are the following: path: The relative or absolute route to your swagger yaml file. The default value is the current directory file: The name of you swagger yaml file. The default value is swagger.yaml url: The url where swagger run in your server. The default value is /ui/ . project_dir: Relative path of the project folder to automatic routing, See this link for more info . The default value is project . See Routing in this documentation to how configure your Swagger.","title":"Configuration"},{"location":"services/services/#example","text":"pyms: services: swagger: path: \"swagger\" file: \"swagger.yaml\" url: \"/ui/\" project_dir: \"project.views\"","title":"Example"},{"location":"services/services/#requests","text":"Extend the requests library with trace headers and parsing JSON objects. Encapsulates common rest operations between business services propagating trace headers if set up.","title":"Requests"},{"location":"services/services/#installation_1","text":"You must install pyms with pip install py-ms[all] or pip install py-ms[request]","title":"Installation"},{"location":"services/services/#configuration_1","text":"The parameters you can add to your config are: data: wrap the response in a data field of an envelope object, and add other meta data to that wrapper. The default value is None retries: If the response is not correct, this specifies the amount of times it performs the request again. The default number of retries is 3. status_retries: List of response status codes that are considered \"not correct\". The default values are [500, 502, 504] propagate_headers: Propagate the headers of the current execution to the request. The default values is False","title":"Configuration"},{"location":"services/services/#example_1","text":"pyms: services: requests: data: \"data\" retries: 4 status_retries: [400, 401, 402, 403, 404, 405, 500, 501, 502, 503] propagate_headers: true","title":"Example"},{"location":"services/services/#tracer","text":"Add traces to all executions with opentracing . This service solves the problem of distributed tracing See Propagate traces tutorial in this documentation for more information.","title":"Tracer"},{"location":"services/services/#installation_2","text":"You must install pyms with pip install pyms[all] or pip install pyms[trace]","title":"Installation"},{"location":"services/services/#configuration_2","text":"The parameters you can add to your config are: client: set the client that will receive the traces, The current options are Jaeger and Lightstep . The default value is jaeger. host: The url to send the data of traces. Check this tutorial to create your own server component_name: The name of your application to show in Prometheus metrics","title":"Configuration"},{"location":"services/services/#example_2","text":"pyms: services: tracer: client: \"jaeger\" host: \"localhost\" component_name: \"Python Microservice\"","title":"Example"},{"location":"services/services/#metrics","text":"Adds Prometheus metrics using the Prometheus Client Library . The following metrics are currently available: Incoming requests latency as a histogram Incoming requests number as a counter, divided by HTTP method, endpoint and HTTP status Total number of log events divided by level If tracer service activated and it's jaeger, it will show its metrics","title":"Metrics"},{"location":"services/services/#installation_3","text":"You must install pyms with pip install py-ms[all] or pip install py-ms[metrics]","title":"Installation"},{"location":"services/services/#example_3","text":"pyms: services: metrics: true This will add the endpoint /metrics to your microservice, which will expose the metrics.","title":"Example"},{"location":"services/services/#service-discovery","text":"Adds Consul as service discovery using the Consul Client Library or create your own service discovery See Service Ddiscovery section in this documentation for more information.","title":"Service discovery"},{"location":"services/services/#installation_4","text":"You must install pyms with pip install py-ms[all] or pip install py-ms[consul]","title":"Installation"},{"location":"services/services/#example_4","text":"pyms: services: service_discovery: service: consul host: localhost port: 8500 autoregister: true This will add the endpoint /metrics to your microservice, which will expose the metrics.","title":"Example"},{"location":"services/services/#how-to-contrib","text":"See tutorial","title":"How to contrib:"},{"location":"services/services_discovery/","text":"Service Discovery PyMS support at this moment this service discovery Consul Eureka (TODO) Kubernetes (TODO) Consul This service use Consul Client Library to connect to Consul pyms: services: service_discovery: service: \"consul\" host: \"localhost\" autoregister: true config: DEBUG: true TESTING: false APP_NAME: \"Python Microservice\" APPLICATION_ROOT: \"\" Check your local configuration with Docker. Run: docker run -d --net=host -e 'CONSUL_LOCAL_CONFIG={\"leave_on_terminate\": true, \"enable_script_checks\": true}' consul Open http://localhost:8500/ to check if Consul is up. If it's ok, when you run your microservice with autoregister: true parameter, you will see in Consul your microservice like this image: Consulate client You can use all consulate options with ms.service_discovery.client or current_app.ms.service_discovery.client . In example: ms.service_discovery.client.agent.checks() See official docs for more information. Create your own Service Discovery Instead of define a service keyword, you can point to a class in your proyect that inherit from ServiceDiscoveryBase (see example above) pyms: services: service_discovery: service: \"myproject.servicesdiscovery_file.MySvcDiscovery\" host: \"localhost\" autoregister: true config: DEBUG: true TESTING: false APP_NAME: \"Python Microservice\" APPLICATION_ROOT: \"\" Under myproject/servicesdiscovery_file.py : from pyms.flask.services.service_discovery import ServiceDiscoveryBase class ServiceDiscoveryConsulBasic(ServiceDiscoveryBase): def register_service(self, id_app, host, port, healtcheck_url, app_name): headers = {\"Content-Type\": \"application/json; charset=utf-8\"} data = { \"id\": app_name + \"-\" + id_app, \"name\": app_name, \"check\": {\"name\": \"ping check\", \"http\": healtcheck_url, \"interval\": \"30s\", \"status\": \"passing\"}, } response = requests.put( \"http://{host}:{port}/v1/agent/service/register\".format(host=host, port=port), data=json.dumps(data), headers=headers, ) if response.status_code != 200: raise Exception(response.content)","title":"Service Discovery"},{"location":"services/services_discovery/#service-discovery","text":"PyMS support at this moment this service discovery Consul Eureka (TODO) Kubernetes (TODO)","title":"Service Discovery"},{"location":"services/services_discovery/#consul","text":"This service use Consul Client Library to connect to Consul pyms: services: service_discovery: service: \"consul\" host: \"localhost\" autoregister: true config: DEBUG: true TESTING: false APP_NAME: \"Python Microservice\" APPLICATION_ROOT: \"\" Check your local configuration with Docker. Run: docker run -d --net=host -e 'CONSUL_LOCAL_CONFIG={\"leave_on_terminate\": true, \"enable_script_checks\": true}' consul Open http://localhost:8500/ to check if Consul is up. If it's ok, when you run your microservice with autoregister: true parameter, you will see in Consul your microservice like this image:","title":"Consul"},{"location":"services/services_discovery/#consulate-client","text":"You can use all consulate options with ms.service_discovery.client or current_app.ms.service_discovery.client . In example: ms.service_discovery.client.agent.checks() See official docs for more information.","title":"Consulate client"},{"location":"services/services_discovery/#create-your-own-service-discovery","text":"Instead of define a service keyword, you can point to a class in your proyect that inherit from ServiceDiscoveryBase (see example above) pyms: services: service_discovery: service: \"myproject.servicesdiscovery_file.MySvcDiscovery\" host: \"localhost\" autoregister: true config: DEBUG: true TESTING: false APP_NAME: \"Python Microservice\" APPLICATION_ROOT: \"\" Under myproject/servicesdiscovery_file.py : from pyms.flask.services.service_discovery import ServiceDiscoveryBase class ServiceDiscoveryConsulBasic(ServiceDiscoveryBase): def register_service(self, id_app, host, port, healtcheck_url, app_name): headers = {\"Content-Type\": \"application/json; charset=utf-8\"} data = { \"id\": app_name + \"-\" + id_app, \"name\": app_name, \"check\": {\"name\": \"ping check\", \"http\": healtcheck_url, \"interval\": \"30s\", \"status\": \"passing\"}, } response = requests.put( \"http://{host}:{port}/v1/agent/service/register\".format(host=host, port=port), data=json.dumps(data), headers=headers, ) if response.status_code != 200: raise Exception(response.content)","title":"Create your own Service Discovery"},{"location":"template/","text":"Cookiecutter Python Microservice Cookiecutter template for a Python microservice. GitHub repo: https://github.com/python-microservices/microservices-template Features Create a \"ready to work\" microservice project like our Microservice Scaffold Deploy your microservice with Microservice chassis pattern powered by PyMS , Flask , Connexion and Opentracing . Testing setup with py.test Travis-CI : Ready for Travis Continuous Integration testing Tox testing: Setup to easily test for Python 3.6 Mkdocs docs: Documentation ready for generation with, for example Quick Start Install the latest Cookiecutter if you haven't installed it yet (this requires Cookiecutter 1.4.0 or higher): $ pip install --upgrade virtualenv $ virtualenv env $ source env/bin/activate $ pip install -U cookiecutter Generate a Python Microservice project: (env) $ cookiecutter https://github.com/python-microservices/microservices-template.git project_repo_url [https://github.com/python-microservices/microservices-scaffold]: project_name [Python Microservices Boilerplate]: prueba descarga project_folder [prueba_descarga]: project_short_description [Python Boilerplate contains all the boilerplate you need to create a Python package.]: create_model_class [y]: microservice_with_swagger_and_connexion [y]: microservice_with_traces [y]: microservice_with_metrics [y]: application_root [/prueba_descarga]: Select open_source_license: 1 - MIT license 2 - BSD license 3 - ISC license 4 - Apache Software License 2.0 5 - GNU General Public License v3 6 - Not open source Choose from 1, 2, 3, 4, 5, 6 [1]: Installation Install with virtualenv virtualenv --python=python[3.6|3.7|3.8] venv source venv/bin/activate pip install -r requirements.txt Install with pipenv pip install pipenv pipenv install Advantages over plain pip and requirements.txt Pipenv generates two files: a Pipfile and a Pipfile.lock . * Pipfile : Is a high level declaration of the dependencies of your project. It can contain \"dev\" dependencies (usually test related stuff) and \"standard\" dependencies which are the ones you'll need for your project to function * Pipfile.lock : Is the \"list\" of all the dependencies your Pipfile has installed, along with their version and their hashes. This prevents two things: Conflicts between dependencies and installing a malicious module. For a more in-depth explanation please refer to the official documentation . Run your python script python manage.py runserver Check the result Your default endpoints will be in this url: http://127.0.0.1:5000/films/ http://127.0.0.1:5000/actors/ This URL is set in your config.yml : pyms: config: DEBUG: false TESTING: false APP_NAME: Template APPLICATION_ROOT : \"\" # <!--- You can acceded to a swagger ui in the next url: http://127.0.0.1:5000/ui/ This PATH is set in your config.yml : pyms: services: swagger: path: \"swagger\" file: \"swagger.yaml\" url: \"/ui/\" # <!--- Docker You can dockerize this microservice wit this steps: * Create and push the image bash docker build -t films -f Dockerfile . * Run the image: bash docker run -d -p 5000:5000 films","title":"Index"},{"location":"template/#cookiecutter-python-microservice","text":"Cookiecutter template for a Python microservice. GitHub repo: https://github.com/python-microservices/microservices-template","title":"Cookiecutter Python Microservice"},{"location":"template/#features","text":"Create a \"ready to work\" microservice project like our Microservice Scaffold Deploy your microservice with Microservice chassis pattern powered by PyMS , Flask , Connexion and Opentracing . Testing setup with py.test Travis-CI : Ready for Travis Continuous Integration testing Tox testing: Setup to easily test for Python 3.6 Mkdocs docs: Documentation ready for generation with, for example","title":"Features"},{"location":"template/#quick-start","text":"Install the latest Cookiecutter if you haven't installed it yet (this requires Cookiecutter 1.4.0 or higher): $ pip install --upgrade virtualenv $ virtualenv env $ source env/bin/activate $ pip install -U cookiecutter Generate a Python Microservice project: (env) $ cookiecutter https://github.com/python-microservices/microservices-template.git project_repo_url [https://github.com/python-microservices/microservices-scaffold]: project_name [Python Microservices Boilerplate]: prueba descarga project_folder [prueba_descarga]: project_short_description [Python Boilerplate contains all the boilerplate you need to create a Python package.]: create_model_class [y]: microservice_with_swagger_and_connexion [y]: microservice_with_traces [y]: microservice_with_metrics [y]: application_root [/prueba_descarga]: Select open_source_license: 1 - MIT license 2 - BSD license 3 - ISC license 4 - Apache Software License 2.0 5 - GNU General Public License v3 6 - Not open source Choose from 1, 2, 3, 4, 5, 6 [1]:","title":"Quick Start"},{"location":"template/#installation","text":"","title":"Installation"},{"location":"template/#install-with-virtualenv","text":"virtualenv --python=python[3.6|3.7|3.8] venv source venv/bin/activate pip install -r requirements.txt","title":"Install with virtualenv"},{"location":"template/#install-with-pipenv","text":"pip install pipenv pipenv install","title":"Install with pipenv"},{"location":"template/#advantages-over-plain-pip-and-requirementstxt","text":"Pipenv generates two files: a Pipfile and a Pipfile.lock . * Pipfile : Is a high level declaration of the dependencies of your project. It can contain \"dev\" dependencies (usually test related stuff) and \"standard\" dependencies which are the ones you'll need for your project to function * Pipfile.lock : Is the \"list\" of all the dependencies your Pipfile has installed, along with their version and their hashes. This prevents two things: Conflicts between dependencies and installing a malicious module. For a more in-depth explanation please refer to the official documentation .","title":"Advantages over plain pip and requirements.txt"},{"location":"template/#run-your-python-script","text":"python manage.py runserver","title":"Run your python script"},{"location":"template/#check-the-result","text":"Your default endpoints will be in this url: http://127.0.0.1:5000/films/ http://127.0.0.1:5000/actors/ This URL is set in your config.yml : pyms: config: DEBUG: false TESTING: false APP_NAME: Template APPLICATION_ROOT : \"\" # <!--- You can acceded to a swagger ui in the next url: http://127.0.0.1:5000/ui/ This PATH is set in your config.yml : pyms: services: swagger: path: \"swagger\" file: \"swagger.yaml\" url: \"/ui/\" # <!---","title":"Check the result"},{"location":"template/#docker","text":"You can dockerize this microservice wit this steps: * Create and push the image bash docker build -t films -f Dockerfile . * Run the image: bash docker run -d -p 5000:5000 films","title":"Docker"},{"location":"tutorials/examples/","text":"Examples Example 1: Basic Example pip install py-ms[all] config.yml: pyms: config: app_name: \"Python Microservice\" main.py from flask import jsonify, current_app from pyms.flask.app import Microservice ms = Microservice() app = ms.create_app() @app.route(\"/\") def example(): return jsonify({\"main\": \"hello world {}\".format(current_app.config[\"APP_NAME\"])}) if __name__ == '__main__': app.run() python main.py Open in your browser http://localhost:5000/ Example 2: Create your Microservice class Create a class that inherits from pyms.flask.app.Microservice and overrides methods with your own configuration. The next example show how to innit a lib like Flask Babel main.py: from flask_babel import Babel from pyms.flask.app import Microservice class MyMicroservice(Microservice): def init_libs(self): babel = Babel(self.application) return self.application ms = MyMicroservice() app = ms.create_app() Example 2: Initialize SQLAlchemy The next example shows us how to innit a lib like Flask SQLAlchemy config.yml: pyms: config: DEBUG: true APP_NAME: MyDB APPLICATION_ROOT: \"\" SQLALCHEMY_DATABASE_URI: mysql+mysqlconnector://user:pass@0.0.0.0/myschema main.py: from flask_sqlalchemy import SQLAlchemy from pyms.flask.app import Microservice DB = SQLAlchemy() class MyMicroservice(Microservice): def init_libs(self): self.application.config[\"SQLALCHEMY_ENGINE_OPTIONS\"] = { 'pool_size': 10, 'pool_recycle': 120, 'pool_pre_ping': True } DB.init_app(self.application) ms = MyMicroservice() app = ms.create_app() Example 3: Create your logger The next example shows us how to create a personal logger for your application import logging.config from pyms.flask.app import Microservice class MyMicroservice(Microservice): def init_logger(self): level = \"INFO\" LOGGING = { 'version': 1, 'disable_existing_loggers': False, 'formatters': { 'console': { 'format': '[%(asctime)s][%(levelname)s] %(name)s ' '%(filename)s:%(funcName)s:%(lineno)d | %(message)s', 'datefmt': '%H:%M:%S', }, }, 'handlers': { 'console': { 'level': level, 'class': 'logging.StreamHandler', 'formatter': 'console' }, }, 'loggers': { '': { 'handlers': ['console'], 'level': level, 'propagate': True, }, 'root': { 'handlers': ['console'], 'level': level, 'propagate': True, }, } } logging.config.dictConfig(LOGGING) ms = MyMicroservice(path=__file__) app = ms.create_app() See this Github page to see more examples","title":"Basic Examples"},{"location":"tutorials/examples/#examples","text":"","title":"Examples"},{"location":"tutorials/examples/#example-1-basic-example","text":"pip install py-ms[all] config.yml: pyms: config: app_name: \"Python Microservice\" main.py from flask import jsonify, current_app from pyms.flask.app import Microservice ms = Microservice() app = ms.create_app() @app.route(\"/\") def example(): return jsonify({\"main\": \"hello world {}\".format(current_app.config[\"APP_NAME\"])}) if __name__ == '__main__': app.run() python main.py Open in your browser http://localhost:5000/","title":"Example 1: Basic Example"},{"location":"tutorials/examples/#example-2-create-your-microservice-class","text":"Create a class that inherits from pyms.flask.app.Microservice and overrides methods with your own configuration. The next example show how to innit a lib like Flask Babel main.py: from flask_babel import Babel from pyms.flask.app import Microservice class MyMicroservice(Microservice): def init_libs(self): babel = Babel(self.application) return self.application ms = MyMicroservice() app = ms.create_app()","title":"Example 2: Create your Microservice class"},{"location":"tutorials/examples/#example-2-initialize-sqlalchemy","text":"The next example shows us how to innit a lib like Flask SQLAlchemy config.yml: pyms: config: DEBUG: true APP_NAME: MyDB APPLICATION_ROOT: \"\" SQLALCHEMY_DATABASE_URI: mysql+mysqlconnector://user:pass@0.0.0.0/myschema main.py: from flask_sqlalchemy import SQLAlchemy from pyms.flask.app import Microservice DB = SQLAlchemy() class MyMicroservice(Microservice): def init_libs(self): self.application.config[\"SQLALCHEMY_ENGINE_OPTIONS\"] = { 'pool_size': 10, 'pool_recycle': 120, 'pool_pre_ping': True } DB.init_app(self.application) ms = MyMicroservice() app = ms.create_app()","title":"Example 2: Initialize SQLAlchemy"},{"location":"tutorials/examples/#example-3-create-your-logger","text":"The next example shows us how to create a personal logger for your application import logging.config from pyms.flask.app import Microservice class MyMicroservice(Microservice): def init_logger(self): level = \"INFO\" LOGGING = { 'version': 1, 'disable_existing_loggers': False, 'formatters': { 'console': { 'format': '[%(asctime)s][%(levelname)s] %(name)s ' '%(filename)s:%(funcName)s:%(lineno)d | %(message)s', 'datefmt': '%H:%M:%S', }, }, 'handlers': { 'console': { 'level': level, 'class': 'logging.StreamHandler', 'formatter': 'console' }, }, 'loggers': { '': { 'handlers': ['console'], 'level': level, 'propagate': True, }, 'root': { 'handlers': ['console'], 'level': level, 'propagate': True, }, } } logging.config.dictConfig(LOGGING) ms = MyMicroservice(path=__file__) app = ms.create_app() See this Github page to see more examples","title":"Example 3: Create your logger"},{"location":"tutorials/tutorial_create_services/","text":"Tutorial 2: How To contribute, Create your own service First, you must create a file with the name of your service inside of pyms.flask.service , for example, \"myawesomesrv\": pyms/flask/services/myawesomesrv.py from pyms.flask.services.driver import DriverService class Service(DriverService): service = \"myawesomesrv\" default_values = { \"myvalue\": 0, \"myvalue2\": 1 } Now, you can configure your service from config.yml pyms: services: myawesomesrv: myvalue: 5 myvalue2: 5 All configuration in myawesomesrv (myvalue, myvalue2) is loaded in self.config : self.config.myvalue and self.config.myvalue2 . When you \"call\" an attribute of your service, DriverService searchs in self.config , and self.config contains the key-values that you've defined in your config.yaml for this service. Therefore, each key in your config.yaml is an attribute of your Service. Your service will be instanced inside the ms object in flask.current_app object. For example, with the last config, you could print the folowing code: from flask import jsonify, current_app from pyms.flask.app import Microservice ms = Microservice(service=\"my-minimal-microservice\", path=__file__) app = ms.create_app() @app.route(\"/\") def example(): return jsonify({ \"myvalue\": current_app.ms.myawesomesrv.myvalue, \"myvalue2\": current_app.ms.myawesomesrv.myvalue2 }) if __name__ == '__main__': app.run() This would be the output in http://localhost:5000/ : {\"myvalue\": 5, \"myvalue2\": 1}","title":"Create services"},{"location":"tutorials/tutorial_create_services/#tutorial-2-how-to-contribute-create-your-own-service","text":"First, you must create a file with the name of your service inside of pyms.flask.service , for example, \"myawesomesrv\": pyms/flask/services/myawesomesrv.py from pyms.flask.services.driver import DriverService class Service(DriverService): service = \"myawesomesrv\" default_values = { \"myvalue\": 0, \"myvalue2\": 1 } Now, you can configure your service from config.yml pyms: services: myawesomesrv: myvalue: 5 myvalue2: 5 All configuration in myawesomesrv (myvalue, myvalue2) is loaded in self.config : self.config.myvalue and self.config.myvalue2 . When you \"call\" an attribute of your service, DriverService searchs in self.config , and self.config contains the key-values that you've defined in your config.yaml for this service. Therefore, each key in your config.yaml is an attribute of your Service. Your service will be instanced inside the ms object in flask.current_app object. For example, with the last config, you could print the folowing code: from flask import jsonify, current_app from pyms.flask.app import Microservice ms = Microservice(service=\"my-minimal-microservice\", path=__file__) app = ms.create_app() @app.route(\"/\") def example(): return jsonify({ \"myvalue\": current_app.ms.myawesomesrv.myvalue, \"myvalue2\": current_app.ms.myawesomesrv.myvalue2 }) if __name__ == '__main__': app.run() This would be the output in http://localhost:5000/ : {\"myvalue\": 5, \"myvalue2\": 1}","title":"Tutorial 2: How To contribute, Create your own service"},{"location":"tutorials/tutorial_propagate_traces/","text":"Tutorial 1: Propagate Traces With this tutorial you can solve the problem of distributed tracing You have applied the Microservice architecture pattern. Requests often span multiple services. Each service handles a request by performing one or more operations, e.g. database queries, publishes messages, etc. PyMS injects a unique request ID with opentracing and passes the external request id to all services that are involved in handling the current request with the service request 1. Simple Trace Install PyMS bash pip install py-ms[all] Create a config file with traces and requests enabled config.yml: pyms: services: requests: propagate_headers: true tracer: client: \"jaeger\" host: \"localhost\" component_name: \"Python Microservice\" config: debug: true main.py from flask import jsonify, current_app, request from pyms.flask.app import Microservice ms = Microservice() app = ms.create_app() @app.route(\"/\") def index(): app.logger.info(\"There are my headers: \\n{}\".format(request.headers)) return jsonify({\"main\": \"hello world {}\".format(current_app.config[\"APP_NAME\"])}) if __name__ == '__main__': app.run() Run this script with: python main.py In another terminal, run this command: curl 'http://localhost:5000/' { \"main\": \"hello world Python Microservice\" } Your script main.py return a log like: { \"message\": \"There are my headers: \\nHost: localhost:5000\\r\\nUser-Agent: curl/7.58.0\\r\\nAccept: */*\\r\\n\\r\\n\", \"timestamp\": \"2020-03-14T10:31:55.430289Z\", \"severity\": \"INFO\", \"service\": \"python microservice\", \"trace\": \"90999056092ac078\", \"span\": \"d7e15e52c8c27214\", \"parent\": \"\" } 2. Propagate Trace Create a second script with this config and this code in main.py pyms: services: requests: propagate_headers: true tracer: client: \"jaeger\" host: \"localhost\" component_name: \"Python Microservice\" config: debug: true main.py from flask import jsonify, current_app, request from pyms.flask.app import Microservice ms = Microservice() app = ms.create_app() @app.route(\"/\") def index(): app.logger.info(\"There are my headers: \\n{}\".format(request.headers)) response = app.ms.requests.get(\"http://localhost:5000/\") return jsonify({\"response\": response.json()}) if __name__ == '__main__': app.run(port=5001) Now, run both this script and the first script. You should have the first one running on http://localhost:5000/ and this new one on http://localhost:5001/ In another terminal, run this command: curl 'http://localhost:5001/' { \"main\": \"hello world Python Microservice\" } The second MS will print these logs: {\"message\": \"There are my headers: \\nHost: localhost:5001\\r\\nUser-Agent: curl/7.58.0\\r\\nAccept: */*\\r\\n\\r\\n\", \"timestamp\": \"2020-03-14T10:52:25.522844Z\", \"severity\": \"INFO\", \"service\": \"python microservice2\", \"trace\": \"bb785b88d0456d69\", \"span\": \"c92e9babb0d002de\", \"parent\": \"\" } {\"message\": \"Get with url http://localhost:5000/, params None, headers {'X-B3-TraceId': 'bb785b88d0456d69', 'X-B3-SpanId': 'c92e9babb0d002de', 'X-B3-Sampled': '1'}, kwargs {}\", \"timestamp\": \"2020-03-14T10:52:25.523169Z\", \"severity\": \"DEBUG\", \"service\": \"python microservice2\", \"trace\": \"bb785b88d0456d69\", \"span\": \"c92e9babb0d002de\", \"parent\": \"\"} {\"message\": \"Response <Response [200]>\", \"timestamp\": \"2020-03-14T10:52:25.528784Z\", \"severity\": \"DEBUG\", \"service\": \"python microservice2\", \"trace\": \"bb785b88d0456d69\", \"span\": \"c92e9babb0d002de\", \"parent\": \"\"} And the first MS return: {\"message\": \"There are my headers: \\nHost: localhost:5000\\r\\nUser-Agent: python-requests/2.23.0\\r\\nAccept-Encoding: gzip, deflate\\r\\nAccept: */*\\r\\nConnection: keep-alive\\r\\nX-B3-Traceid: bb785b88d0456d69\\r\\nX-B3-Spanid: c92e9babb0d002de\\r\\nX-B3-Sampled: 1\\r\\n\\r\\n\", \"timestamp\": \"2020-03-14T10:52:25.527177Z\", \"severity\": \"INFO\", \"service\": \"python microservice\", \"trace\": \"bb785b88d0456d69\", \"span\": \"a01a2ea1a908f997\", \"parent\": \"c92e9babb0d002de\"} As you can see, both microservices have \"trace\": \"bb785b88d0456d69\" . Flow You can see the flow of these requests in this diagram: Code You can check this example on this Github page The simplest way to start the all-in-one is to use the pre-built image published to DockerHub (a single command line). Tracer server You can see the traces with jaeger server : $ docker run -d --name jaeger \\ -e COLLECTOR_ZIPKIN_HTTP_PORT=9411 \\ -p 5775:5775/udp \\ -p 6831:6831/udp \\ -p 6832:6832/udp \\ -p 5778:5778 \\ -p 16686:16686 \\ -p 14268:14268 \\ -p 14250:14250 \\ -p 9411:9411 \\ jaegertracing/all-in-one:1.20 You can then navigate to http://localhost:16686 to access the Jaeger UI.","title":"Propagate traces"},{"location":"tutorials/tutorial_propagate_traces/#tutorial-1-propagate-traces","text":"With this tutorial you can solve the problem of distributed tracing You have applied the Microservice architecture pattern. Requests often span multiple services. Each service handles a request by performing one or more operations, e.g. database queries, publishes messages, etc. PyMS injects a unique request ID with opentracing and passes the external request id to all services that are involved in handling the current request with the service request","title":"Tutorial 1: Propagate Traces"},{"location":"tutorials/tutorial_propagate_traces/#1-simple-trace","text":"Install PyMS bash pip install py-ms[all] Create a config file with traces and requests enabled config.yml: pyms: services: requests: propagate_headers: true tracer: client: \"jaeger\" host: \"localhost\" component_name: \"Python Microservice\" config: debug: true main.py from flask import jsonify, current_app, request from pyms.flask.app import Microservice ms = Microservice() app = ms.create_app() @app.route(\"/\") def index(): app.logger.info(\"There are my headers: \\n{}\".format(request.headers)) return jsonify({\"main\": \"hello world {}\".format(current_app.config[\"APP_NAME\"])}) if __name__ == '__main__': app.run() Run this script with: python main.py In another terminal, run this command: curl 'http://localhost:5000/' { \"main\": \"hello world Python Microservice\" } Your script main.py return a log like: { \"message\": \"There are my headers: \\nHost: localhost:5000\\r\\nUser-Agent: curl/7.58.0\\r\\nAccept: */*\\r\\n\\r\\n\", \"timestamp\": \"2020-03-14T10:31:55.430289Z\", \"severity\": \"INFO\", \"service\": \"python microservice\", \"trace\": \"90999056092ac078\", \"span\": \"d7e15e52c8c27214\", \"parent\": \"\" }","title":"1. Simple Trace"},{"location":"tutorials/tutorial_propagate_traces/#2-propagate-trace","text":"Create a second script with this config and this code in main.py pyms: services: requests: propagate_headers: true tracer: client: \"jaeger\" host: \"localhost\" component_name: \"Python Microservice\" config: debug: true main.py from flask import jsonify, current_app, request from pyms.flask.app import Microservice ms = Microservice() app = ms.create_app() @app.route(\"/\") def index(): app.logger.info(\"There are my headers: \\n{}\".format(request.headers)) response = app.ms.requests.get(\"http://localhost:5000/\") return jsonify({\"response\": response.json()}) if __name__ == '__main__': app.run(port=5001) Now, run both this script and the first script. You should have the first one running on http://localhost:5000/ and this new one on http://localhost:5001/ In another terminal, run this command: curl 'http://localhost:5001/' { \"main\": \"hello world Python Microservice\" } The second MS will print these logs: {\"message\": \"There are my headers: \\nHost: localhost:5001\\r\\nUser-Agent: curl/7.58.0\\r\\nAccept: */*\\r\\n\\r\\n\", \"timestamp\": \"2020-03-14T10:52:25.522844Z\", \"severity\": \"INFO\", \"service\": \"python microservice2\", \"trace\": \"bb785b88d0456d69\", \"span\": \"c92e9babb0d002de\", \"parent\": \"\" } {\"message\": \"Get with url http://localhost:5000/, params None, headers {'X-B3-TraceId': 'bb785b88d0456d69', 'X-B3-SpanId': 'c92e9babb0d002de', 'X-B3-Sampled': '1'}, kwargs {}\", \"timestamp\": \"2020-03-14T10:52:25.523169Z\", \"severity\": \"DEBUG\", \"service\": \"python microservice2\", \"trace\": \"bb785b88d0456d69\", \"span\": \"c92e9babb0d002de\", \"parent\": \"\"} {\"message\": \"Response <Response [200]>\", \"timestamp\": \"2020-03-14T10:52:25.528784Z\", \"severity\": \"DEBUG\", \"service\": \"python microservice2\", \"trace\": \"bb785b88d0456d69\", \"span\": \"c92e9babb0d002de\", \"parent\": \"\"} And the first MS return: {\"message\": \"There are my headers: \\nHost: localhost:5000\\r\\nUser-Agent: python-requests/2.23.0\\r\\nAccept-Encoding: gzip, deflate\\r\\nAccept: */*\\r\\nConnection: keep-alive\\r\\nX-B3-Traceid: bb785b88d0456d69\\r\\nX-B3-Spanid: c92e9babb0d002de\\r\\nX-B3-Sampled: 1\\r\\n\\r\\n\", \"timestamp\": \"2020-03-14T10:52:25.527177Z\", \"severity\": \"INFO\", \"service\": \"python microservice\", \"trace\": \"bb785b88d0456d69\", \"span\": \"a01a2ea1a908f997\", \"parent\": \"c92e9babb0d002de\"} As you can see, both microservices have \"trace\": \"bb785b88d0456d69\" .","title":"2. Propagate Trace"},{"location":"tutorials/tutorial_propagate_traces/#flow","text":"You can see the flow of these requests in this diagram:","title":"Flow"},{"location":"tutorials/tutorial_propagate_traces/#code","text":"You can check this example on this Github page The simplest way to start the all-in-one is to use the pre-built image published to DockerHub (a single command line).","title":"Code"},{"location":"tutorials/tutorial_propagate_traces/#tracer-server","text":"You can see the traces with jaeger server : $ docker run -d --name jaeger \\ -e COLLECTOR_ZIPKIN_HTTP_PORT=9411 \\ -p 5775:5775/udp \\ -p 6831:6831/udp \\ -p 6832:6832/udp \\ -p 5778:5778 \\ -p 16686:16686 \\ -p 14268:14268 \\ -p 14250:14250 \\ -p 9411:9411 \\ jaegertracing/all-in-one:1.20 You can then navigate to http://localhost:16686 to access the Jaeger UI.","title":"Tracer server"},{"location":"tutorials/tutorial_testing/","text":"Tutorial 3: Testing with Pytest and PyMS Testing a microservice with PyMS is very similar to a Flask Application. Create App Pattern The recommended way to start is using Create App Pattern . Using PyMS is like Flask: from pyms.flask.app import Microservice def create_app(): ms = Microservice(path=__file__) return ms.create_app() Conftest.py and Pytest Then, you can use these functions in your conftest.py with Pytest: Config environment PyMS needs the environment variable PYMS_CONFIGMAP_FILE to look for the configuration file, is recommended to create a specific config file to testing: import os def conf_environment(): if not os.environ.get(\"PYMS_CONFIGMAP_FILE\", False): os.environ[\"PYMS_CONFIGMAP_FILE\"] = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"config-tests.yml\") Initialize Flask Create an app object to use in tests import pytest @pytest.fixture(scope=\"session\") def app(): conf_environment() app = create_app() return app Initialize Flask Create Flask testing client @pytest.fixture(scope=\"module\") def client(app, db): \"\"\"A test client for the app.\"\"\" return app.test_client() Extra: url of your tests Get the url to use in tests @pytest.fixture(scope=\"module\") def base_url(app): \"\"\"Base url of the service.\"\"\" return app.config[\"APPLICATION_ROOT\"]() Ready to testing your code With this configuration, you are ready to create your own tests with PyMS: def test_list_actors(client, base_url): response = client.get('{base_url}healthcheck'.format(base_url=base_url)) assert 200 == response.status_code As you can see, is very similar to a normal Flask application :)","title":"Testing with PyMS"},{"location":"tutorials/tutorial_testing/#tutorial-3-testing-with-pytest-and-pyms","text":"Testing a microservice with PyMS is very similar to a Flask Application.","title":"Tutorial 3: Testing with Pytest and PyMS"},{"location":"tutorials/tutorial_testing/#create-app-pattern","text":"The recommended way to start is using Create App Pattern . Using PyMS is like Flask: from pyms.flask.app import Microservice def create_app(): ms = Microservice(path=__file__) return ms.create_app()","title":"Create App Pattern"},{"location":"tutorials/tutorial_testing/#conftestpy-and-pytest","text":"Then, you can use these functions in your conftest.py with Pytest:","title":"Conftest.py and Pytest"},{"location":"tutorials/tutorial_testing/#config-environment","text":"PyMS needs the environment variable PYMS_CONFIGMAP_FILE to look for the configuration file, is recommended to create a specific config file to testing: import os def conf_environment(): if not os.environ.get(\"PYMS_CONFIGMAP_FILE\", False): os.environ[\"PYMS_CONFIGMAP_FILE\"] = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"config-tests.yml\")","title":"Config environment"},{"location":"tutorials/tutorial_testing/#initialize-flask","text":"Create an app object to use in tests import pytest @pytest.fixture(scope=\"session\") def app(): conf_environment() app = create_app() return app","title":"Initialize Flask"},{"location":"tutorials/tutorial_testing/#initialize-flask_1","text":"Create Flask testing client @pytest.fixture(scope=\"module\") def client(app, db): \"\"\"A test client for the app.\"\"\" return app.test_client()","title":"Initialize Flask"},{"location":"tutorials/tutorial_testing/#extra-url-of-your-tests","text":"Get the url to use in tests @pytest.fixture(scope=\"module\") def base_url(app): \"\"\"Base url of the service.\"\"\" return app.config[\"APPLICATION_ROOT\"]()","title":"Extra: url of your tests"},{"location":"tutorials/tutorial_testing/#ready-to-testing-your-code","text":"With this configuration, you are ready to create your own tests with PyMS: def test_list_actors(client, base_url): response = client.get('{base_url}healthcheck'.format(base_url=base_url)) assert 200 == response.status_code As you can see, is very similar to a normal Flask application :)","title":"Ready to testing your code"},{"location":"tutorials/tutorials/","text":"Tutorials This section shows tutorials for advanced use of PyMS. See Examples for simple tutorials Tutorial 1: Propagate Traces With this tutorial you can solve the problem of distributed tracing See tutorial Tutorial 2: How To contribute, Create your own service See tutorial Tutorial 3: Testing with Pytest and PyMS See tutorial","title":"Index"},{"location":"tutorials/tutorials/#tutorials","text":"This section shows tutorials for advanced use of PyMS. See Examples for simple tutorials","title":"Tutorials"},{"location":"tutorials/tutorials/#tutorial-1-propagate-traces","text":"With this tutorial you can solve the problem of distributed tracing See tutorial","title":"Tutorial 1: Propagate Traces"},{"location":"tutorials/tutorials/#tutorial-2-how-to-contribute-create-your-own-service","text":"See tutorial","title":"Tutorial 2: How To contribute, Create your own service"},{"location":"tutorials/tutorials/#tutorial-3-testing-with-pytest-and-pyms","text":"See tutorial","title":"Tutorial 3: Testing with Pytest and PyMS"}]}